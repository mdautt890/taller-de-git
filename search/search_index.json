{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Inicio \u00b6 Este taller forma parte de las actividades del Aula de Software Libre de la Universidad de C\u00f3rdoba . El contenido del mismo es en parte de producci\u00f3n propia, en parte de otros manuales libres que pueden encontrarse en la secci\u00f3n de Referencias . Contenido \u00b6 Inicio Sistemas de control de versiones Introducci\u00f3n a Git Aspectos b\u00e1sicos de Git Uso b\u00e1sico Uso avanzado Ramas Administraci\u00f3n de repositorios Flujo de trabajo con Git (git flow) Github Referencias Agradecimientos \u00b6 Este curso ha sido impartido por las siguientes personas: Adri\u00e1n L\u00f3pez H\u00e9ctor Romero Javier de Santiago Jos\u00e9 M\u00e1rquez Sergio G\u00f3mez Licencia \u00b6 El material est\u00e1 publicado con licencia Atribuci\u00f3n-NoComercial 4.0 Internacional (CC BY-NC 4.0)","title":"Inicio"},{"location":"#inicio","text":"Este taller forma parte de las actividades del Aula de Software Libre de la Universidad de C\u00f3rdoba . El contenido del mismo es en parte de producci\u00f3n propia, en parte de otros manuales libres que pueden encontrarse en la secci\u00f3n de Referencias .","title":"Inicio"},{"location":"#contenido","text":"Inicio Sistemas de control de versiones Introducci\u00f3n a Git Aspectos b\u00e1sicos de Git Uso b\u00e1sico Uso avanzado Ramas Administraci\u00f3n de repositorios Flujo de trabajo con Git (git flow) Github Referencias","title":"Contenido"},{"location":"#agradecimientos","text":"Este curso ha sido impartido por las siguientes personas: Adri\u00e1n L\u00f3pez H\u00e9ctor Romero Javier de Santiago Jos\u00e9 M\u00e1rquez Sergio G\u00f3mez","title":"Agradecimientos"},{"location":"#licencia","text":"El material est\u00e1 publicado con licencia Atribuci\u00f3n-NoComercial 4.0 Internacional (CC BY-NC 4.0)","title":"Licencia"},{"location":"commands/","text":"Comandos de git \u00b6 Esta secci\u00f3n describe algunos de los comandos m\u00e1s interesantes de git Git stash (reserva) \u00b6 La orden git stash nos permite salvar moment\u00e1neamente el espacio de trabajo cuando tenemos que cambiar de rama o preparar la rama actual para sincronizar cambios. Las operaciones m\u00e1s importantes que podemos hacer con git stash son: git stash save \u00b6 Es equivalente a poner solo git stash pero nos permite realizar m\u00e1s acciones como: git stash save \"Tu mensaje\" git stash save -u El par\u00e1metro -u permite que se almacen tambi\u00e9n los ficheros sin seguimiento previo ( untracked en ingl\u00e9s, aquellos ficheros que no se han metido nunca en el repositorio). git stash list \u00b6 Permite mostrar la pila del stash. $ git stash list stash@{0}: On master: Stash con mensaje stash@{1}: WIP on master: 4ab21df First commit git stash apply \u00b6 Esta orden coge el stash que est\u00e1 arriba en la pila y lo aplica al espacio de trabajo actual. En este caso siempre es stash@{0} . El stash permanece en la pila. Se puede indicar como par\u00e1metro un stash en concreto. git stash pop \u00b6 Funciona igual que git apply con la diferencia de que el stash s\u00ed se borra de la pila. git stash show \u00b6 Muestra un resumen de los ficheros que se han modificado en ese stash. $ git stash show A.txt | 1 + B.txt | 3 +++ 2 file changed, 4 insertions(+) Para ver los cambios podemos usar el par\u00e1metro -p $ git stash show -p --- a/A.txt +++ b/A.txt @@ -45,6 +45,7 @@ nav: + This is a change Por defecto siempre muestra la cabeza de la pila. Igual que en casos anteriores podemos indicar un stash en concreto. $ git stash show stash@{1} git stash branch \u00b6 Permite crear una nueva rama a partir del \u00faltimo stash. Adem\u00e1s, el mismo es borrado de la pila. Se puede especificar uno en concreto si lo queremos, como en el resto de comandos. git stash branch nombre-de-nueva-rama stash@{1} git stash clear \u00b6 Este comando borrar todos los stash de la pila. Es destructiva y no se puede deshacer. git stash drop \u00b6 Permite borrar un stash en concreto (o el \u00faltimo si no se indica ninguno). Como con clear, borrarlo implica que no se puede recuperar. Git worktree \u00b6 Uno de los problemas m\u00e1s habituales es tener que tocar una rama distinta a la que tenemos actualmente. Eso implica que si estamos en medio de un trabajo tendr\u00edamos que hacer un commit o un stash, lo cual a veces es bastante molesto. Con git worktree podemos crear un directorio de trabajo que contenga otra rama distinta, de forma temporal. No supone otro clon del repositorio porque ambos usan el mismo. git worktree add \u00b6 Esta funci\u00f3n es la que crea el espacio de trabajo temporal. Imaginemos que estamos en una rama llamada develop : $ git worktree add ../project-master master $ git worktree add -b fix ../project-fix master La primera orden crea un directorio llamado project-master que contiene el estado de master. La segunda, que contiene el par\u00e1metro -b equivale a crear una nueva rama llamada fix, que se crea desde master (suponemos que no existe fix). git worktree list \u00b6 Muestra el listado de directorios y espacios de trabajo. $git worktree list /home/sergio/taller-de-git 3b63b4b [master] /home/sergio/fix 3b63b4b [fix] git worktree remove \u00b6 Borrar un espacio de trabajo. Hay que indicar el nombre entre corchetes que aparece en el listado $ git worktree delete fix git worktree prune \u00b6 Una cuesti\u00f3n importante, es que las ramas que est\u00e9n desplegadas en otro espacio de trabajo, se encuentran bloqueadas y no se pueden desbloquear en otro distinto. Esto significa que si estamos trabajando en la rama developer, creamos otro worktree en otro directorio de la rama master, no podemos hacer pasar a master. No es posible tener la misma rama en varios espacios de trabajo. Si se ha borrado el directorio a mano (en vez de usando remove), eso no implica que el bloqueo desparezca. Con esta orden podemos hacer que git compruebe que los espacios de trabajo secundario se comprueben de nuevo para ver si siguen existiendo y se elimine el bloqueo. Git blame \u00b6 Lo ideal en un equipo de desarrollo es que el c\u00f3digo pase por todas las manos para as\u00ed mejorar su calidad. Con git blame podemos saber qui\u00e9n fue el \u00faltimo en modificar una l\u00ednea concreta de c\u00f3digo, en qu\u00e9 commit y en qu\u00e9 fecha lo hizo. $ git blame ejemplo.php 33cdd02c (Sergio G\u00f3mez 2020-01-20 16:58:52 +0100 8) name: \"material\" 33cdd02c (Sergio G\u00f3mez 2020-01-20 16:58:52 +0100 9) language: \"es\"","title":"Comandos de git"},{"location":"commands/#comandos-de-git","text":"Esta secci\u00f3n describe algunos de los comandos m\u00e1s interesantes de git","title":"Comandos de git"},{"location":"commands/#git-stash-reserva","text":"La orden git stash nos permite salvar moment\u00e1neamente el espacio de trabajo cuando tenemos que cambiar de rama o preparar la rama actual para sincronizar cambios. Las operaciones m\u00e1s importantes que podemos hacer con git stash son:","title":"Git stash (reserva)"},{"location":"commands/#git-stash-save","text":"Es equivalente a poner solo git stash pero nos permite realizar m\u00e1s acciones como: git stash save \"Tu mensaje\" git stash save -u El par\u00e1metro -u permite que se almacen tambi\u00e9n los ficheros sin seguimiento previo ( untracked en ingl\u00e9s, aquellos ficheros que no se han metido nunca en el repositorio).","title":"git stash save"},{"location":"commands/#git-stash-list","text":"Permite mostrar la pila del stash. $ git stash list stash@{0}: On master: Stash con mensaje stash@{1}: WIP on master: 4ab21df First commit","title":"git stash list"},{"location":"commands/#git-stash-apply","text":"Esta orden coge el stash que est\u00e1 arriba en la pila y lo aplica al espacio de trabajo actual. En este caso siempre es stash@{0} . El stash permanece en la pila. Se puede indicar como par\u00e1metro un stash en concreto.","title":"git stash apply"},{"location":"commands/#git-stash-pop","text":"Funciona igual que git apply con la diferencia de que el stash s\u00ed se borra de la pila.","title":"git stash pop"},{"location":"commands/#git-stash-show","text":"Muestra un resumen de los ficheros que se han modificado en ese stash. $ git stash show A.txt | 1 + B.txt | 3 +++ 2 file changed, 4 insertions(+) Para ver los cambios podemos usar el par\u00e1metro -p $ git stash show -p --- a/A.txt +++ b/A.txt @@ -45,6 +45,7 @@ nav: + This is a change Por defecto siempre muestra la cabeza de la pila. Igual que en casos anteriores podemos indicar un stash en concreto. $ git stash show stash@{1}","title":"git stash show"},{"location":"commands/#git-stash-branch","text":"Permite crear una nueva rama a partir del \u00faltimo stash. Adem\u00e1s, el mismo es borrado de la pila. Se puede especificar uno en concreto si lo queremos, como en el resto de comandos. git stash branch nombre-de-nueva-rama stash@{1}","title":"git stash branch"},{"location":"commands/#git-stash-clear","text":"Este comando borrar todos los stash de la pila. Es destructiva y no se puede deshacer.","title":"git stash clear"},{"location":"commands/#git-stash-drop","text":"Permite borrar un stash en concreto (o el \u00faltimo si no se indica ninguno). Como con clear, borrarlo implica que no se puede recuperar.","title":"git stash drop"},{"location":"commands/#git-worktree","text":"Uno de los problemas m\u00e1s habituales es tener que tocar una rama distinta a la que tenemos actualmente. Eso implica que si estamos en medio de un trabajo tendr\u00edamos que hacer un commit o un stash, lo cual a veces es bastante molesto. Con git worktree podemos crear un directorio de trabajo que contenga otra rama distinta, de forma temporal. No supone otro clon del repositorio porque ambos usan el mismo.","title":"Git worktree"},{"location":"commands/#git-worktree-add","text":"Esta funci\u00f3n es la que crea el espacio de trabajo temporal. Imaginemos que estamos en una rama llamada develop : $ git worktree add ../project-master master $ git worktree add -b fix ../project-fix master La primera orden crea un directorio llamado project-master que contiene el estado de master. La segunda, que contiene el par\u00e1metro -b equivale a crear una nueva rama llamada fix, que se crea desde master (suponemos que no existe fix).","title":"git worktree add"},{"location":"commands/#git-worktree-list","text":"Muestra el listado de directorios y espacios de trabajo. $git worktree list /home/sergio/taller-de-git 3b63b4b [master] /home/sergio/fix 3b63b4b [fix]","title":"git worktree list"},{"location":"commands/#git-worktree-remove","text":"Borrar un espacio de trabajo. Hay que indicar el nombre entre corchetes que aparece en el listado $ git worktree delete fix","title":"git worktree remove"},{"location":"commands/#git-worktree-prune","text":"Una cuesti\u00f3n importante, es que las ramas que est\u00e9n desplegadas en otro espacio de trabajo, se encuentran bloqueadas y no se pueden desbloquear en otro distinto. Esto significa que si estamos trabajando en la rama developer, creamos otro worktree en otro directorio de la rama master, no podemos hacer pasar a master. No es posible tener la misma rama en varios espacios de trabajo. Si se ha borrado el directorio a mano (en vez de usando remove), eso no implica que el bloqueo desparezca. Con esta orden podemos hacer que git compruebe que los espacios de trabajo secundario se comprueben de nuevo para ver si siguen existiendo y se elimine el bloqueo.","title":"git worktree prune"},{"location":"commands/#git-blame","text":"Lo ideal en un equipo de desarrollo es que el c\u00f3digo pase por todas las manos para as\u00ed mejorar su calidad. Con git blame podemos saber qui\u00e9n fue el \u00faltimo en modificar una l\u00ednea concreta de c\u00f3digo, en qu\u00e9 commit y en qu\u00e9 fecha lo hizo. $ git blame ejemplo.php 33cdd02c (Sergio G\u00f3mez 2020-01-20 16:58:52 +0100 8) name: \"material\" 33cdd02c (Sergio G\u00f3mez 2020-01-20 16:58:52 +0100 9) language: \"es\"","title":"Git blame"},{"location":"cvs/","text":"Sistemas de control de versiones \u00b6 Definici\u00f3n, clasificaci\u00f3n y funcionamiento \u00b6 Se llama control de versiones a la gesti\u00f3n de los diversos cambios que se realizan sobre los elementos de alg\u00fan producto o una configuraci\u00f3n del mismo. Una versi\u00f3n, revisi\u00f3n o edici\u00f3n de un producto, es el estado en el que se encuentra dicho producto en un momento dado de su desarrollo o modificaci\u00f3n. Aunque un sistema de control de versiones puede realizarse de forma manual, es muy aconsejable disponer de herramientas que faciliten esta gesti\u00f3n dando lugar a los llamados sistemas de control de versiones o SVC (del ingl\u00e9s System Version Control). Estos sistemas facilitan la administraci\u00f3n de las distintas versiones de cada producto desarrollado, as\u00ed como las posibles especializaciones realizadas (por ejemplo, para alg\u00fan cliente espec\u00edfico). Ejemplos de este tipo de herramientas son entre otros: CVS, Subversion, SourceSafe, ClearCase, Darcs, Bazaar , Plastic SCM, Git, Mercurial, Perforce. Terminolog\u00eda \u00b6 Repositorio (\"repository\") El repositorio es el lugar en el que se almacenan los datos actualizados e hist\u00f3ricos de cambios. Revisi\u00f3n (\"revision\") Una revisi\u00f3n es una versi\u00f3n determinada de la informaci\u00f3n que se gestiona. Hay sistemas que identifican las revisiones con un contador (Ej. subversion). Hay otros sistemas que identifican las revisiones mediante un c\u00f3digo de detecci\u00f3n de modificaciones (Ej. git usa SHA1). Etiqueta (\"tag\") Los tags permiten identificar de forma f\u00e1cil revisiones importantes en el proyecto. Por ejemplo se suelen usar tags para identificar el contenido de las versiones publicadas del proyecto. Rama (\"branch\") Un conjunto de archivos puede ser ramificado o bifurcado en un punto en el tiempo de manera que, a partir de ese momento, dos copias de esos archivos se pueden desarrollar a velocidades diferentes o en formas diferentes de forma independiente el uno del otro. Cambio (\"change\") Un cambio (o diff, o delta) representa una modificaci\u00f3n espec\u00edfica de un documento bajo el control de versiones. La granularidad de la modificaci\u00f3n que es considerada como un cambio var\u00eda entre los sistemas de control de versiones. Desplegar (\"checkout\") Es crear una copia de trabajo local desde el repositorio. Un usuario puede especificar una revisi\u00f3n en concreto u obtener la \u00faltima. El t\u00e9rmino 'checkout' tambi\u00e9n se puede utilizar como un sustantivo para describir la copia de trabajo. Confirmar (\"commit\") Confirmar es escribir o mezclar los cambios realizados en la copia de trabajo del repositorio. Los t\u00e9rminos 'commit' y 'checkin' tambi\u00e9n se pueden utilizar como sustantivos para describir la nueva revisi\u00f3n que se crea como resultado de confirmar. Conflicto (\"conflict\") Un conflicto se produce cuando diferentes partes realizan cambios en el mismo documento, y el sistema es incapaz de conciliar los cambios. Un usuario debe resolver el conflicto mediante la integraci\u00f3n de los cambios, o mediante la selecci\u00f3n de un cambio en favor del otro. Cabeza (\"head\") Tambi\u00e9n a veces se llama tip (punta) y se refiere a la \u00faltima confirmaci\u00f3n, ya sea en el tronco ('trunk') o en una rama ('branch'). El tronco y cada rama tienen su propia cabeza, aunque HEAD se utiliza a veces libremente para referirse al tronco. Tronco (\"trunk\") La \u00fanica l\u00ednea de desarrollo que no es una rama (a veces tambi\u00e9n llamada l\u00ednea base, l\u00ednea principal o m\u00e1ster). Fusionar, integrar, mezclar (\"merge\") Una fusi\u00f3n o integraci\u00f3n es una operaci\u00f3n en la que se aplican dos tipos de cambios en un archivo o conjunto de archivos. Algunos escenarios de ejemplo son los siguientes: Un usuario, trabajando en un conjunto de archivos, actualiza o sincroniza su copia de trabajo con los cambios realizados y confirmados, por otros usuarios, en el repositorio. Un usuario intenta confirmar archivos que han sido actualizado por otros usuarios desde el \u00faltimo despliegue ('checkout'), y el software de control de versiones integra autom\u00e1ticamente los archivos (por lo general, despu\u00e9s de preguntarle al usuario si se debe proceder con la integraci\u00f3n autom\u00e1tica, y en algunos casos s\u00f3lo se hace si la fusi\u00f3n puede ser clara y razonablemente resuelta). Un conjunto de archivos se bifurca, un problema que exist\u00eda antes de la ramificaci\u00f3n se trabaja en una nueva rama, y la soluci\u00f3n se combina luego en la otra rama. Se crea una rama, el c\u00f3digo de los archivos es independiente editado, y la rama actualizada se incorpora m\u00e1s tarde en un \u00fanico tronco unificado. Clasificaci\u00f3n \u00b6 Podemos clasificar los sistemas de control de versiones atendiendo a la arquitectura utilizada para el almacenamiento del c\u00f3digo: locales, centralizados y distribuidos. Locales \u00b6 Los cambios son guardados localmente y no se comparten con nadie. Esta arquitectura es la antecesora de las dos siguientes. Centralizados \u00b6 Existe un repositorio centralizado de todo el c\u00f3digo, del cual es responsable un \u00fanico usuario (o conjunto de ellos). Se facilitan las tareas administrativas a cambio de reducir flexibilidad, pues todas las decisiones fuertes (como crear una nueva rama) necesitan la aprobaci\u00f3n del responsable. Algunos ejemplos son CVS y Subversion. Distribuidos \u00b6 Cada usuario tiene su propio repositorio. Los distintos repositorios pueden intercambiar y mezclar revisiones entre ellos. Es frecuente el uso de un repositorio, que est\u00e1 normalmente disponible, que sirve de punto de sincronizaci\u00f3n de los distintos repositorios locales. Ejemplos: Git y Mercurial. Ventajas de sistemas distribuidos \u00b6 No es necesario estar conectado para guardar cambios. Posibilidad de continuar trabajando si el repositorio remoto no est\u00e1 accesible. El repositorio central est\u00e1 m\u00e1s libre de ramas de pruebas. Se necesitan menos recursos para el repositorio remoto. M\u00e1s flexibles al permitir gestionar cada repositorio personal como se quiera.","title":"Sistemas de control de versiones"},{"location":"cvs/#sistemas-de-control-de-versiones","text":"","title":"Sistemas de control de versiones"},{"location":"cvs/#definicion-clasificacion-y-funcionamiento","text":"Se llama control de versiones a la gesti\u00f3n de los diversos cambios que se realizan sobre los elementos de alg\u00fan producto o una configuraci\u00f3n del mismo. Una versi\u00f3n, revisi\u00f3n o edici\u00f3n de un producto, es el estado en el que se encuentra dicho producto en un momento dado de su desarrollo o modificaci\u00f3n. Aunque un sistema de control de versiones puede realizarse de forma manual, es muy aconsejable disponer de herramientas que faciliten esta gesti\u00f3n dando lugar a los llamados sistemas de control de versiones o SVC (del ingl\u00e9s System Version Control). Estos sistemas facilitan la administraci\u00f3n de las distintas versiones de cada producto desarrollado, as\u00ed como las posibles especializaciones realizadas (por ejemplo, para alg\u00fan cliente espec\u00edfico). Ejemplos de este tipo de herramientas son entre otros: CVS, Subversion, SourceSafe, ClearCase, Darcs, Bazaar , Plastic SCM, Git, Mercurial, Perforce.","title":"Definici\u00f3n, clasificaci\u00f3n y funcionamiento"},{"location":"cvs/#terminologia","text":"Repositorio (\"repository\") El repositorio es el lugar en el que se almacenan los datos actualizados e hist\u00f3ricos de cambios. Revisi\u00f3n (\"revision\") Una revisi\u00f3n es una versi\u00f3n determinada de la informaci\u00f3n que se gestiona. Hay sistemas que identifican las revisiones con un contador (Ej. subversion). Hay otros sistemas que identifican las revisiones mediante un c\u00f3digo de detecci\u00f3n de modificaciones (Ej. git usa SHA1). Etiqueta (\"tag\") Los tags permiten identificar de forma f\u00e1cil revisiones importantes en el proyecto. Por ejemplo se suelen usar tags para identificar el contenido de las versiones publicadas del proyecto. Rama (\"branch\") Un conjunto de archivos puede ser ramificado o bifurcado en un punto en el tiempo de manera que, a partir de ese momento, dos copias de esos archivos se pueden desarrollar a velocidades diferentes o en formas diferentes de forma independiente el uno del otro. Cambio (\"change\") Un cambio (o diff, o delta) representa una modificaci\u00f3n espec\u00edfica de un documento bajo el control de versiones. La granularidad de la modificaci\u00f3n que es considerada como un cambio var\u00eda entre los sistemas de control de versiones. Desplegar (\"checkout\") Es crear una copia de trabajo local desde el repositorio. Un usuario puede especificar una revisi\u00f3n en concreto u obtener la \u00faltima. El t\u00e9rmino 'checkout' tambi\u00e9n se puede utilizar como un sustantivo para describir la copia de trabajo. Confirmar (\"commit\") Confirmar es escribir o mezclar los cambios realizados en la copia de trabajo del repositorio. Los t\u00e9rminos 'commit' y 'checkin' tambi\u00e9n se pueden utilizar como sustantivos para describir la nueva revisi\u00f3n que se crea como resultado de confirmar. Conflicto (\"conflict\") Un conflicto se produce cuando diferentes partes realizan cambios en el mismo documento, y el sistema es incapaz de conciliar los cambios. Un usuario debe resolver el conflicto mediante la integraci\u00f3n de los cambios, o mediante la selecci\u00f3n de un cambio en favor del otro. Cabeza (\"head\") Tambi\u00e9n a veces se llama tip (punta) y se refiere a la \u00faltima confirmaci\u00f3n, ya sea en el tronco ('trunk') o en una rama ('branch'). El tronco y cada rama tienen su propia cabeza, aunque HEAD se utiliza a veces libremente para referirse al tronco. Tronco (\"trunk\") La \u00fanica l\u00ednea de desarrollo que no es una rama (a veces tambi\u00e9n llamada l\u00ednea base, l\u00ednea principal o m\u00e1ster). Fusionar, integrar, mezclar (\"merge\") Una fusi\u00f3n o integraci\u00f3n es una operaci\u00f3n en la que se aplican dos tipos de cambios en un archivo o conjunto de archivos. Algunos escenarios de ejemplo son los siguientes: Un usuario, trabajando en un conjunto de archivos, actualiza o sincroniza su copia de trabajo con los cambios realizados y confirmados, por otros usuarios, en el repositorio. Un usuario intenta confirmar archivos que han sido actualizado por otros usuarios desde el \u00faltimo despliegue ('checkout'), y el software de control de versiones integra autom\u00e1ticamente los archivos (por lo general, despu\u00e9s de preguntarle al usuario si se debe proceder con la integraci\u00f3n autom\u00e1tica, y en algunos casos s\u00f3lo se hace si la fusi\u00f3n puede ser clara y razonablemente resuelta). Un conjunto de archivos se bifurca, un problema que exist\u00eda antes de la ramificaci\u00f3n se trabaja en una nueva rama, y la soluci\u00f3n se combina luego en la otra rama. Se crea una rama, el c\u00f3digo de los archivos es independiente editado, y la rama actualizada se incorpora m\u00e1s tarde en un \u00fanico tronco unificado.","title":"Terminolog\u00eda"},{"location":"cvs/#clasificacion","text":"Podemos clasificar los sistemas de control de versiones atendiendo a la arquitectura utilizada para el almacenamiento del c\u00f3digo: locales, centralizados y distribuidos.","title":"Clasificaci\u00f3n"},{"location":"cvs/#locales","text":"Los cambios son guardados localmente y no se comparten con nadie. Esta arquitectura es la antecesora de las dos siguientes.","title":"Locales"},{"location":"cvs/#centralizados","text":"Existe un repositorio centralizado de todo el c\u00f3digo, del cual es responsable un \u00fanico usuario (o conjunto de ellos). Se facilitan las tareas administrativas a cambio de reducir flexibilidad, pues todas las decisiones fuertes (como crear una nueva rama) necesitan la aprobaci\u00f3n del responsable. Algunos ejemplos son CVS y Subversion.","title":"Centralizados"},{"location":"cvs/#distribuidos","text":"Cada usuario tiene su propio repositorio. Los distintos repositorios pueden intercambiar y mezclar revisiones entre ellos. Es frecuente el uso de un repositorio, que est\u00e1 normalmente disponible, que sirve de punto de sincronizaci\u00f3n de los distintos repositorios locales. Ejemplos: Git y Mercurial.","title":"Distribuidos"},{"location":"cvs/#ventajas-de-sistemas-distribuidos","text":"No es necesario estar conectado para guardar cambios. Posibilidad de continuar trabajando si el repositorio remoto no est\u00e1 accesible. El repositorio central est\u00e1 m\u00e1s libre de ramas de pruebas. Se necesitan menos recursos para el repositorio remoto. M\u00e1s flexibles al permitir gestionar cada repositorio personal como se quiera.","title":"Ventajas de sistemas distribuidos"},{"location":"git/","text":"Aspectos b\u00e1sicos de Git \u00b6 Instalaci\u00f3n \u00b6 Instalando en Linux \u00b6 Si quieres instalar Git en Linux a trav\u00e9s de un instalador binario, en general puedes hacerlo a trav\u00e9s de la herramienta b\u00e1sica de gesti\u00f3n de paquetes que trae tu distribuci\u00f3n. Si est\u00e1s en Fedora, puedes usar yum: $ yum install git-core O si est\u00e1s en una distribuci\u00f3n basada en Debian como Ubuntu, prueba con apt-get: $ apt-get install git Instalando en Windows \u00b6 Instalar Git en Windows es muy f\u00e1cil. El proyecto msysGit tiene uno de los procesos de instalaci\u00f3n m\u00e1s sencillos. Simplemente descarga el archivo exe del instalador desde la p\u00e1gina de GitHub, y ejec\u00fatalo: http://msysgit.github.com/ Una vez instalado, tendr\u00e1s tanto la versi\u00f3n de l\u00ednea de comandos (incluido un cliente SSH que nos ser\u00e1 \u00fatil m\u00e1s adelante) como la interfaz gr\u00e1fica de usuario est\u00e1ndar. Se recomienda no modificar las opciones que trae por defecto el instalador. Instalando en MacOS \u00b6 En MacOS se recomienda tener instalada la herramienta homebrew . Despu\u00e9s, es tan f\u00e1cil como ejecutar: $ brew install git Configuraci\u00f3n \u00b6 Tu identidad \u00b6 Lo primero que deber\u00edas hacer cuando instalas Git es establecer tu nombre de usuario y direcci\u00f3n de correo electr\u00f3nico. Esto es importante porque las confirmaciones de cambios (commits) en Git usan esta informaci\u00f3n, y es introducida de manera inmutable en los commits que env\u00edas: $ git config --global user.name \"John Doe\" $ git config --global user.email johndoe@example.com Tambi\u00e9n se recomienda configurar el siguiente par\u00e1metro: $ git config --global push.default simple Bash Completion \u00b6 Bash completion es una utilidad que permite a bash completar \u00f3rdenes y par\u00e1metros. Por defecto suele venir desactivada en Ubuntu y es necesario modificar el archivo $HOME/.bashrc para poder activarla. Simplemente hay que descomentar las l\u00edneas que lo activan,","title":"Aspectos b\u00e1sicos de Git"},{"location":"git/#aspectos-basicos-de-git","text":"","title":"Aspectos b\u00e1sicos de Git"},{"location":"git/#instalacion","text":"","title":"Instalaci\u00f3n"},{"location":"git/#instalando-en-linux","text":"Si quieres instalar Git en Linux a trav\u00e9s de un instalador binario, en general puedes hacerlo a trav\u00e9s de la herramienta b\u00e1sica de gesti\u00f3n de paquetes que trae tu distribuci\u00f3n. Si est\u00e1s en Fedora, puedes usar yum: $ yum install git-core O si est\u00e1s en una distribuci\u00f3n basada en Debian como Ubuntu, prueba con apt-get: $ apt-get install git","title":"Instalando en Linux"},{"location":"git/#instalando-en-windows","text":"Instalar Git en Windows es muy f\u00e1cil. El proyecto msysGit tiene uno de los procesos de instalaci\u00f3n m\u00e1s sencillos. Simplemente descarga el archivo exe del instalador desde la p\u00e1gina de GitHub, y ejec\u00fatalo: http://msysgit.github.com/ Una vez instalado, tendr\u00e1s tanto la versi\u00f3n de l\u00ednea de comandos (incluido un cliente SSH que nos ser\u00e1 \u00fatil m\u00e1s adelante) como la interfaz gr\u00e1fica de usuario est\u00e1ndar. Se recomienda no modificar las opciones que trae por defecto el instalador.","title":"Instalando en Windows"},{"location":"git/#instalando-en-macos","text":"En MacOS se recomienda tener instalada la herramienta homebrew . Despu\u00e9s, es tan f\u00e1cil como ejecutar: $ brew install git","title":"Instalando en MacOS"},{"location":"git/#configuracion","text":"","title":"Configuraci\u00f3n"},{"location":"git/#tu-identidad","text":"Lo primero que deber\u00edas hacer cuando instalas Git es establecer tu nombre de usuario y direcci\u00f3n de correo electr\u00f3nico. Esto es importante porque las confirmaciones de cambios (commits) en Git usan esta informaci\u00f3n, y es introducida de manera inmutable en los commits que env\u00edas: $ git config --global user.name \"John Doe\" $ git config --global user.email johndoe@example.com Tambi\u00e9n se recomienda configurar el siguiente par\u00e1metro: $ git config --global push.default simple","title":"Tu identidad"},{"location":"git/#bash-completion","text":"Bash completion es una utilidad que permite a bash completar \u00f3rdenes y par\u00e1metros. Por defecto suele venir desactivada en Ubuntu y es necesario modificar el archivo $HOME/.bashrc para poder activarla. Simplemente hay que descomentar las l\u00edneas que lo activan,","title":"Bash Completion"},{"location":"gitflow/","text":"Flujo de trabajo con Git (git flow) \u00b6 La importancia de la organizaci\u00f3n del flujo de trabajo \u00b6 En la introducci\u00f3n vimos los diferentes esquemas de organizaci\u00f3n externa de los repositorios (es decir, en lo relativo a los usuarios que componen el equipo de trabajo). Pero el repositorio en s\u00ed tambi\u00e9n tiene su esquema de organizaci\u00f3n. En los ejemplos hemos visto que usabamos una rama m\u00e1ster y cre\u00e1bamos ramas para a\u00f1adir funcionalidades que luego integr\u00e1bamos. Es un forma de trabajar de las muchas que hay propuestas, posiblemente la m\u00e1s simple, pero tiene el inconveniente de dejar la rama m\u00e1ster a expensas de una mala actualizaci\u00f3n y quedarnos sin una rama estable. Por eso, hay otras propuestas mejores que permiten separar el trabajo de desarrollo con el mantenimiento de las versiones estables. Una de las m\u00e1s conocidas es la propuesta por Vincent Driessen y que podemos ver en la figura siguiente. Las ramas principales \u00b6 En este esquema hay dos ramas principales con un tiempo de vida indefinido: master ( origin/master ): el c\u00f3digo apuntado por HEAD siempre contiene un estado listo para producci\u00f3n. develop ( origin/develop ): el c\u00f3digo apuntado por HEAD siempre contiene los \u00faltimos cambios desarrollados para la pr\u00f3xima versi\u00f3n del software. Tambi\u00e9n se le puede llamar rama de integraci\u00f3n . No es necesariamente estable. Cuando el c\u00f3digo de la rama de desarrollo es lo suficientemente estable, se integra con la rama master y una nueva versi\u00f3n es lanzada. Las ramas auxiliares \u00b6 Para labores concretas, pueden usarse otro tipo de ramas, las cuales tienen un tiempo de vida definido. Es decir, cuando ya no son necesarias se eliminan: Ramas de funcionalidad (feature branches) Ramas de versi\u00f3n (release branches) Ramas de parches (hotfix branches) Feature branches \u00b6 Pueden partir de: develop Deben fusionarse con: develop Convenici\u00f3n de nombres: feature-NUMissue-*. Release branches \u00b6 Pueden partir de: develop Deben fusionarse con: develop y master Convenici\u00f3n de nombres: release-* Hotfix branches \u00b6 Pueden partir de: master Deben fusionarse con: develop y master Convenici\u00f3n de nombres: hotfix-* La extensi\u00f3n flow de Git \u00b6 Una de las ventajas de Git es que, adem\u00e1s, es extensible. Es decir, se pueden crear nuevas \u00f3rdenes como si de plugins se tratara. Una de las m\u00e1s usadas es gitflow , que est\u00e1 basada en el art\u00edculo que hablamos al principio de este cap\u00edtulo. Instalaci\u00f3n \u00b6 Aunque la fuente original de la extensi\u00f3n es del mismo autor del art\u00edculo, el c\u00f3digo no se encuentra ya muy actualizado y hay un fork bastante m\u00e1s activo en petervanderdoes/gitflow . En el wiki del repositorio est\u00e1n las instrucciones de instalaci\u00f3n para distintos sistemas. Una vez instalados tendremos una nueva \u00f3rden: git flow . Uso \u00b6 Para cambiar a las ramas master y develop, seguiremos usando git checkout , pero para trabajar con las ramas antes indicadas gitflow nos facilita las siguientes \u00f3rdenes: - git flow init: \u00b6 Inicializa el espacio de trabajo. De forma autom\u00e1tica, crea las ramas que necesitamos y permite configurar el nombre de las mismas. $ git flow init Initialized empty Git repository in ~/project/.git/ No branches exist yet. Base branches must be created now. Branch name for production releases: [master] Branch name for \"next release\" development: [develop] How to name your supporting branch prefixes? Feature branches? [feature/] Release branches? [release/] Hotfix branches? [hotfix/] Support branches? [support/] Version tag prefix? [] $ git branch * develop master Podemos ver que por defecto (usando intro en vez de escribir nada) pone nombres por defecto a cada rama. Con git branch comprobamos que ramas existen y en cual nos encontramos. - git flow feature: \u00b6 Permite crear y trabajar con ramas de funcionalidades. $ git flow feature start feature_branch As\u00ed creamos una rama 'feature/feature_branch' y nos mueve autom\u00e1ticamente a ella. En esta haremos los cambios que queramos en nuestro repositorio. Cuando queramos acabar de usar la rama, haremos un commit y la finalizaremos: $ git flow feature stop feature_branch Esto finaliza nuestra rama y la integra autom\u00e1ticamente a la rama develop. Si queremos seguir cambiando nuestro repositorio abriremos una nueva rama feature. - git flow release: \u00b6 Permite crear y trabajar con ramas de versiones. Cuando entendemos que despues de todas las funcionalidades (features, cambios en nuestro repositorio) nuestro trabajo esta listo para ser publicado, abriremos una rama release, que nacera de nuestra rama develop. $ git flow release start 0.1.0 Switched to a new branch 'release/0.1.0' Usaremos un tag para identificar de que release se trata. Ahora podemos hacer los cambios que estimemos oportuno para integrar todas las features que el repositorio ha sufrido hasta el momento. Tras hacer commit a todo el proceso, podemos cerrar la rama release. $git flow release finish '0.1.0' Esto la integrar\u00e1 de forma autom\u00e1tica con master (con esto finalizamos el proceso de 'subir a producci\u00f3n' nuestro codigo) y con la rama develop, para que las futuras features est\u00e9n al d\u00eda. - git flow hotfix: \u00b6 Permite crear y trabajar con ramas de parches. Esto lo usaremos para hacer cambios rapidos que no puedan esperar a la proxima integracion de una release. $ git flow hotfix start hotfix_branch Tras hacer commit finalizamos la rama hotfix. Esta se fusionar\u00e1 con nuestra rama master y con nuestra rama develop para que esta tambi\u00e9n est\u00e9 al d\u00eda de los \u00faltimos cambios. $ git flow hotfix finish hotfix_branch","title":"Flujo de trabajo con Git (git flow)"},{"location":"gitflow/#flujo-de-trabajo-con-git-git-flow","text":"","title":"Flujo de trabajo con Git (git flow)"},{"location":"gitflow/#la-importancia-de-la-organizacion-del-flujo-de-trabajo","text":"En la introducci\u00f3n vimos los diferentes esquemas de organizaci\u00f3n externa de los repositorios (es decir, en lo relativo a los usuarios que componen el equipo de trabajo). Pero el repositorio en s\u00ed tambi\u00e9n tiene su esquema de organizaci\u00f3n. En los ejemplos hemos visto que usabamos una rama m\u00e1ster y cre\u00e1bamos ramas para a\u00f1adir funcionalidades que luego integr\u00e1bamos. Es un forma de trabajar de las muchas que hay propuestas, posiblemente la m\u00e1s simple, pero tiene el inconveniente de dejar la rama m\u00e1ster a expensas de una mala actualizaci\u00f3n y quedarnos sin una rama estable. Por eso, hay otras propuestas mejores que permiten separar el trabajo de desarrollo con el mantenimiento de las versiones estables. Una de las m\u00e1s conocidas es la propuesta por Vincent Driessen y que podemos ver en la figura siguiente.","title":"La importancia de la organizaci\u00f3n del flujo de trabajo"},{"location":"gitflow/#las-ramas-principales","text":"En este esquema hay dos ramas principales con un tiempo de vida indefinido: master ( origin/master ): el c\u00f3digo apuntado por HEAD siempre contiene un estado listo para producci\u00f3n. develop ( origin/develop ): el c\u00f3digo apuntado por HEAD siempre contiene los \u00faltimos cambios desarrollados para la pr\u00f3xima versi\u00f3n del software. Tambi\u00e9n se le puede llamar rama de integraci\u00f3n . No es necesariamente estable. Cuando el c\u00f3digo de la rama de desarrollo es lo suficientemente estable, se integra con la rama master y una nueva versi\u00f3n es lanzada.","title":"Las ramas principales"},{"location":"gitflow/#las-ramas-auxiliares","text":"Para labores concretas, pueden usarse otro tipo de ramas, las cuales tienen un tiempo de vida definido. Es decir, cuando ya no son necesarias se eliminan: Ramas de funcionalidad (feature branches) Ramas de versi\u00f3n (release branches) Ramas de parches (hotfix branches)","title":"Las ramas auxiliares"},{"location":"gitflow/#feature-branches","text":"Pueden partir de: develop Deben fusionarse con: develop Convenici\u00f3n de nombres: feature-NUMissue-*.","title":"Feature branches"},{"location":"gitflow/#release-branches","text":"Pueden partir de: develop Deben fusionarse con: develop y master Convenici\u00f3n de nombres: release-*","title":"Release branches"},{"location":"gitflow/#hotfix-branches","text":"Pueden partir de: master Deben fusionarse con: develop y master Convenici\u00f3n de nombres: hotfix-*","title":"Hotfix branches"},{"location":"gitflow/#la-extension-flow-de-git","text":"Una de las ventajas de Git es que, adem\u00e1s, es extensible. Es decir, se pueden crear nuevas \u00f3rdenes como si de plugins se tratara. Una de las m\u00e1s usadas es gitflow , que est\u00e1 basada en el art\u00edculo que hablamos al principio de este cap\u00edtulo.","title":"La extensi\u00f3n flow de Git"},{"location":"gitflow/#instalacion","text":"Aunque la fuente original de la extensi\u00f3n es del mismo autor del art\u00edculo, el c\u00f3digo no se encuentra ya muy actualizado y hay un fork bastante m\u00e1s activo en petervanderdoes/gitflow . En el wiki del repositorio est\u00e1n las instrucciones de instalaci\u00f3n para distintos sistemas. Una vez instalados tendremos una nueva \u00f3rden: git flow .","title":"Instalaci\u00f3n"},{"location":"gitflow/#uso","text":"Para cambiar a las ramas master y develop, seguiremos usando git checkout , pero para trabajar con las ramas antes indicadas gitflow nos facilita las siguientes \u00f3rdenes:","title":"Uso"},{"location":"gitflow/#-git-flow-init","text":"Inicializa el espacio de trabajo. De forma autom\u00e1tica, crea las ramas que necesitamos y permite configurar el nombre de las mismas. $ git flow init Initialized empty Git repository in ~/project/.git/ No branches exist yet. Base branches must be created now. Branch name for production releases: [master] Branch name for \"next release\" development: [develop] How to name your supporting branch prefixes? Feature branches? [feature/] Release branches? [release/] Hotfix branches? [hotfix/] Support branches? [support/] Version tag prefix? [] $ git branch * develop master Podemos ver que por defecto (usando intro en vez de escribir nada) pone nombres por defecto a cada rama. Con git branch comprobamos que ramas existen y en cual nos encontramos.","title":"- git flow init:"},{"location":"gitflow/#-git-flow-feature","text":"Permite crear y trabajar con ramas de funcionalidades. $ git flow feature start feature_branch As\u00ed creamos una rama 'feature/feature_branch' y nos mueve autom\u00e1ticamente a ella. En esta haremos los cambios que queramos en nuestro repositorio. Cuando queramos acabar de usar la rama, haremos un commit y la finalizaremos: $ git flow feature stop feature_branch Esto finaliza nuestra rama y la integra autom\u00e1ticamente a la rama develop. Si queremos seguir cambiando nuestro repositorio abriremos una nueva rama feature.","title":"- git flow feature:"},{"location":"gitflow/#-git-flow-release","text":"Permite crear y trabajar con ramas de versiones. Cuando entendemos que despues de todas las funcionalidades (features, cambios en nuestro repositorio) nuestro trabajo esta listo para ser publicado, abriremos una rama release, que nacera de nuestra rama develop. $ git flow release start 0.1.0 Switched to a new branch 'release/0.1.0' Usaremos un tag para identificar de que release se trata. Ahora podemos hacer los cambios que estimemos oportuno para integrar todas las features que el repositorio ha sufrido hasta el momento. Tras hacer commit a todo el proceso, podemos cerrar la rama release. $git flow release finish '0.1.0' Esto la integrar\u00e1 de forma autom\u00e1tica con master (con esto finalizamos el proceso de 'subir a producci\u00f3n' nuestro codigo) y con la rama develop, para que las futuras features est\u00e9n al d\u00eda.","title":"- git flow release:"},{"location":"gitflow/#-git-flow-hotfix","text":"Permite crear y trabajar con ramas de parches. Esto lo usaremos para hacer cambios rapidos que no puedan esperar a la proxima integracion de una release. $ git flow hotfix start hotfix_branch Tras hacer commit finalizamos la rama hotfix. Esta se fusionar\u00e1 con nuestra rama master y con nuestra rama develop para que esta tambi\u00e9n est\u00e9 al d\u00eda de los \u00faltimos cambios. $ git flow hotfix finish hotfix_branch","title":"- git flow hotfix:"},{"location":"github-avanzado/","text":"Github avanzado \u00b6 Esta secci\u00f3n trata de c\u00f3mo colaborar con proyectos de terceros. Clonar un repositorio \u00b6 Nos vamos a la web del proyecto en el que queremos colaborar. En este caso el proyecto se encuentra en https://github.com/sgomez/miniblog . Pulsamos en el bot\u00f3n de fork y eso crear\u00e1 una copia en nuestro perfil. Una vez se termine de clonar el repositorio, nos encontraremos con el espacio de trabajo del mismo: En la parte superior informaci\u00f3n sobre los commits, ramas, etiquetas, etc. Justo debajo un explorador de archivos. En la parte derecha un selector para cambiar de contexto entre: explorador de c\u00f3digo, peticiones de colaboraci\u00f3n (pull request), wiki, configuraci\u00f3n, etc. Justo abajo a la derecha informaci\u00f3n sobre como clonar localmente o descargar un proyecto. Github nos permite clonar localmente un proyecto por tres v\u00edas: HTTPS, SSH y Subversion. Seleccionamos SSH y copiamos el texto que despu\u00e9s a\u00f1adiremos a la orden git clone como en la primera l\u00ednea del siguiente grupo de \u00f3rdenes: $ git clone git@github.com:miusuario/miniblog.git $ cd miniblog $ composer.phar install $ php console create-schema Lo que hace el c\u00f3digo anterior es: Clona el repositorio localmente Entramos en la copia Instalamos las dependencias que la aplicaci\u00f3n tiene Arrancamos un servidor web para pruebas Y probamos que nuestra aplicaci\u00f3n funciona: $ php -S localhost:9999 -t web/ Podemos usar dos direcciones para probarla: Frontend: http://localhost:9999/index_dev.php Backend: http://localhost:9999/index_dev.php/admin/ con usuario admin y contrase\u00f1a 1234. Sincronizar con el repositorio original \u00b6 Cuando clonamos un repositorio de otro usuario hacemos una copia del original. Pero esa copia es igual al momento en el que hicimos la copia. Cuando el repositorio original cambie, que lo har\u00e1, nuestro repositorio no se actualizar\u00e1 solo. \u00a1Son dos repositorios diferentes! Necesitamos una manera de poder incorporar los cambios que vaya teniendo el repositorio original en el nuestro. Para eso crearemos una nueva rama remota. Por convenio, y como vimos anteriormente, ya existe una rama remota llamada origin que apunta al repositorio de donde clonamos el proyecto, en este caso apunta a nuestro fork en github: $ git remote show origin * remote origin Fetch URL: git@github.com:miusuario/miniblog.git Push URL: git@github.com:miusuario/miniblog.git HEAD branch (remote HEAD is ambiguous, may be one of the following): develop master Remote branches: develop tracked master tracked Local branch configured for 'git pull': master merges with remote master Local ref configured for 'git push': master pushes to master (up to date) Tambi\u00e9n por convenio, la rama remota que hace referencia al repositorio original se llama upstream y se crea de la siguiente manera: $ git remote add upstream git@github.com:sgomez/miniblog.git $ git remote show upstream * remote upstream Fetch URL: git@github.com:sgomez/miniblog.git Push URL: git@github.com:sgomez/miniblog.git HEAD branch: master Remote branches: develop new (next fetch will store in remotes/upstream) master new (next fetch will store in remotes/upstream) Local ref configured for 'git push': master pushes to master (local out of date) En este caso, la URI debe ser siempre la del proyecto original. Y ahora para incorporar actualizaciones, usaremos el merge en dos pasos: $ git fetch upstream $ git merge upstream/master Recordemos que fetch solo trae los cambios que existan en el repositorio remoto sin hacer ning\u00fan cambio en nuestro repositorio. Es la orden merge la que se encarga de que todo est\u00e9 sincronizado. En este caso decimos que queremos fusionar con la rama master que est\u00e1 en el repositorio upstream . Creando nuevas funcionalidades \u00b6 Vamos a crear una nueva funcionalidad: vamos a a\u00f1adir una licencia de uso. Para ello preferentemente crearemos una nueva rama. $ git checkout -b add-license $ echo \"LICENCIA MIT\" > LICESE # el error es intencionado $ git add LICESE $ git commit -m \"Archivo de licencia de uso\" En principio habr\u00eda que probar que todo funciona bien y entonces integraremos en la rama master de nuestro repositorio y enviamos los cambios a Github: $ git checkout master $ git merge add-license --no-ff $ git branch -d add-license # Borramos la rama que ya no nos sirve para nada $ git push --set-upstream origin add-license # Enviamos la rama a nuestro repositorio origin Si volvemos a Github, veremos que nos avisa de que hemos subido una nueva rama y si queremos crear un pull request. Pulsamos y entramos en la petici\u00f3n de Pull Request . Este es el momento para revisar cualquier error antes de enviar al due\u00f1o del repositorio. Como vemos hemos cometido uno, nombrando el fichero, si lo correguimos debemos hacer otro push para ir actualizando la rama. Cuando est\u00e9 lista volvemos aqu\u00ed y continuamos. Hay que dejar una descripci\u00f3n del cambio que vamos a hacer. Una vez hemos terminado y nos aseguramos que todo est\u00e1 correcto, pulsamos Send pull request y le llegar\u00e1 nuestra petici\u00f3n al due\u00f1o del proyecto. Sin embargo, para esta prueba, no vamos a cambiar el nombre del archivo y dejaremos el error como est\u00e1. As\u00ed de esta manera al administrador del proyecto le llegar\u00e1 el Pull Request y la lista de cambios. Ahora en principio, cabr\u00eda esperar que el administrador aprobara los cambios, pero podr\u00eda pasar que nos indicara que cambiemos algo. En ese caso solo habr\u00eda que modificar la rama y volverla a enviar. $ git mv LICESE LICENSE $ git commit -m \"Fix: Nombre de archivo LICENSE\" $ git push Ahora s\u00ed, el administrador puede aprobar la fusi\u00f3n y borrar la rama del repositorio. El panel de Github permite aceptar los cambios directamente o informa de como hacer una copia de la rama ofrecida por el usuario para hacer cambios, como puede verse en la siguiente imagen. Una vez que se han aceptado los cambios, podemos borrar la rama y actualizar nuestro repositorio con los datos del remoto como hicimos antes. \u00bfPor qu\u00e9 actualizar desde el remoto y no desde nuetra rama add-license ? Pues porque usualmente el administrador puede haber modificado los cambios que le hemos propuesto, o incluso una tercera persona. Recordemos el cariz colaborativo que tiene Github. $ git checkout master $ git branch -d add-license # Esto borra la rama local $ git push origin --delete add-license # Esto borra la rama remota. Tambi\u00e9n puede hacerse desde la web. Todo esto es algo complicado... \u00b6 S\u00ed, lo es, al menos al principio. Git tiene una parte muy sencilla que es el uso del repositorio local (\u00f3rdenes tales como add, rm, mv y commit). El siguiente nivel de complejidad lo componen las \u00f3rdenes para trabajar con ramas y fusionarlas (checkout, branch, merge, rebase) y por \u00faltimo, las que trabajan con repositorios remotos (pull, push, fetch, remote). Adem\u00e1s hay otra serie de \u00f3rdenes para tener informaci\u00f3n (diff, log, status) o hacer operaciones de mantenimiento (fsck, gc). Lo importante para no perderse en Git, es seguir la siguiente m\u00e1xima: No avanzar al siguiente nivel de complejidad, hasta no haber entendido completamente el anterior. Muy poco sentido tiene ponernos a crear ramas en github si a\u00fan no entendemos c\u00f3mo se crean localmente y para que deben usarse. En la parte de referencias hay varios manuales en l\u00ednea, incluso tutoriales interactivos. Tambi\u00e9n hay mucha documentaci\u00f3n disponible en Github que suele venir muy bien explicada. En caso de que tengamos un problema que no sepamos resolver, una web muy buena es StackOverflow . Es una web de preguntas y respuestas para profesionales; es muy dif\u00edcil que se os plantee una duda que no haya sido ya preguntada y respondida en esa web. Eso s\u00ed, el ingl\u00e9s es imprescindible. \u00daltimo paso, documentaci\u00f3n. \u00b6 Github permite crear documentaci\u00f3n. En primer lugar, generando un archivo llamado README.md . Tambi\u00e9n permite crear una web propia para el proyecto y, adem\u00e1s, una wiki. Para marcar el texto, se utiliza un lenguaje de marcado de texto denominado Markdown . En la siguiente web hay un tutorial interactivo: http://www.markdowntutorial.com/ . Como en principio, no es necesario saber Markdown para poder trabajar con Git o con Github, no vamos a incidir m\u00e1s en este asunto. En el propio GitHub podemos encontrar algunas plantillas que nos sirvan de referencia. Algunos ejemplos: Plantilla b\u00e1sica Plantilla avanzada Documentaci\u00f3n del curso \u00b6 Esta documentaci\u00f3n est\u00e1 hecha en Markdown y pasada a HTML gracia a la herramienta mkdocs . La plantilla usada es Material for MkDocs . El material est\u00e1 publicado con licencia Atribuci\u00f3n-NoComercial 4.0 Internacional (CC BY-NC 4.0)","title":"Github avanzado"},{"location":"github-avanzado/#github-avanzado","text":"Esta secci\u00f3n trata de c\u00f3mo colaborar con proyectos de terceros.","title":"Github avanzado"},{"location":"github-avanzado/#clonar-un-repositorio","text":"Nos vamos a la web del proyecto en el que queremos colaborar. En este caso el proyecto se encuentra en https://github.com/sgomez/miniblog . Pulsamos en el bot\u00f3n de fork y eso crear\u00e1 una copia en nuestro perfil. Una vez se termine de clonar el repositorio, nos encontraremos con el espacio de trabajo del mismo: En la parte superior informaci\u00f3n sobre los commits, ramas, etiquetas, etc. Justo debajo un explorador de archivos. En la parte derecha un selector para cambiar de contexto entre: explorador de c\u00f3digo, peticiones de colaboraci\u00f3n (pull request), wiki, configuraci\u00f3n, etc. Justo abajo a la derecha informaci\u00f3n sobre como clonar localmente o descargar un proyecto. Github nos permite clonar localmente un proyecto por tres v\u00edas: HTTPS, SSH y Subversion. Seleccionamos SSH y copiamos el texto que despu\u00e9s a\u00f1adiremos a la orden git clone como en la primera l\u00ednea del siguiente grupo de \u00f3rdenes: $ git clone git@github.com:miusuario/miniblog.git $ cd miniblog $ composer.phar install $ php console create-schema Lo que hace el c\u00f3digo anterior es: Clona el repositorio localmente Entramos en la copia Instalamos las dependencias que la aplicaci\u00f3n tiene Arrancamos un servidor web para pruebas Y probamos que nuestra aplicaci\u00f3n funciona: $ php -S localhost:9999 -t web/ Podemos usar dos direcciones para probarla: Frontend: http://localhost:9999/index_dev.php Backend: http://localhost:9999/index_dev.php/admin/ con usuario admin y contrase\u00f1a 1234.","title":"Clonar un repositorio"},{"location":"github-avanzado/#sincronizar-con-el-repositorio-original","text":"Cuando clonamos un repositorio de otro usuario hacemos una copia del original. Pero esa copia es igual al momento en el que hicimos la copia. Cuando el repositorio original cambie, que lo har\u00e1, nuestro repositorio no se actualizar\u00e1 solo. \u00a1Son dos repositorios diferentes! Necesitamos una manera de poder incorporar los cambios que vaya teniendo el repositorio original en el nuestro. Para eso crearemos una nueva rama remota. Por convenio, y como vimos anteriormente, ya existe una rama remota llamada origin que apunta al repositorio de donde clonamos el proyecto, en este caso apunta a nuestro fork en github: $ git remote show origin * remote origin Fetch URL: git@github.com:miusuario/miniblog.git Push URL: git@github.com:miusuario/miniblog.git HEAD branch (remote HEAD is ambiguous, may be one of the following): develop master Remote branches: develop tracked master tracked Local branch configured for 'git pull': master merges with remote master Local ref configured for 'git push': master pushes to master (up to date) Tambi\u00e9n por convenio, la rama remota que hace referencia al repositorio original se llama upstream y se crea de la siguiente manera: $ git remote add upstream git@github.com:sgomez/miniblog.git $ git remote show upstream * remote upstream Fetch URL: git@github.com:sgomez/miniblog.git Push URL: git@github.com:sgomez/miniblog.git HEAD branch: master Remote branches: develop new (next fetch will store in remotes/upstream) master new (next fetch will store in remotes/upstream) Local ref configured for 'git push': master pushes to master (local out of date) En este caso, la URI debe ser siempre la del proyecto original. Y ahora para incorporar actualizaciones, usaremos el merge en dos pasos: $ git fetch upstream $ git merge upstream/master Recordemos que fetch solo trae los cambios que existan en el repositorio remoto sin hacer ning\u00fan cambio en nuestro repositorio. Es la orden merge la que se encarga de que todo est\u00e9 sincronizado. En este caso decimos que queremos fusionar con la rama master que est\u00e1 en el repositorio upstream .","title":"Sincronizar con el repositorio original"},{"location":"github-avanzado/#creando-nuevas-funcionalidades","text":"Vamos a crear una nueva funcionalidad: vamos a a\u00f1adir una licencia de uso. Para ello preferentemente crearemos una nueva rama. $ git checkout -b add-license $ echo \"LICENCIA MIT\" > LICESE # el error es intencionado $ git add LICESE $ git commit -m \"Archivo de licencia de uso\" En principio habr\u00eda que probar que todo funciona bien y entonces integraremos en la rama master de nuestro repositorio y enviamos los cambios a Github: $ git checkout master $ git merge add-license --no-ff $ git branch -d add-license # Borramos la rama que ya no nos sirve para nada $ git push --set-upstream origin add-license # Enviamos la rama a nuestro repositorio origin Si volvemos a Github, veremos que nos avisa de que hemos subido una nueva rama y si queremos crear un pull request. Pulsamos y entramos en la petici\u00f3n de Pull Request . Este es el momento para revisar cualquier error antes de enviar al due\u00f1o del repositorio. Como vemos hemos cometido uno, nombrando el fichero, si lo correguimos debemos hacer otro push para ir actualizando la rama. Cuando est\u00e9 lista volvemos aqu\u00ed y continuamos. Hay que dejar una descripci\u00f3n del cambio que vamos a hacer. Una vez hemos terminado y nos aseguramos que todo est\u00e1 correcto, pulsamos Send pull request y le llegar\u00e1 nuestra petici\u00f3n al due\u00f1o del proyecto. Sin embargo, para esta prueba, no vamos a cambiar el nombre del archivo y dejaremos el error como est\u00e1. As\u00ed de esta manera al administrador del proyecto le llegar\u00e1 el Pull Request y la lista de cambios. Ahora en principio, cabr\u00eda esperar que el administrador aprobara los cambios, pero podr\u00eda pasar que nos indicara que cambiemos algo. En ese caso solo habr\u00eda que modificar la rama y volverla a enviar. $ git mv LICESE LICENSE $ git commit -m \"Fix: Nombre de archivo LICENSE\" $ git push Ahora s\u00ed, el administrador puede aprobar la fusi\u00f3n y borrar la rama del repositorio. El panel de Github permite aceptar los cambios directamente o informa de como hacer una copia de la rama ofrecida por el usuario para hacer cambios, como puede verse en la siguiente imagen. Una vez que se han aceptado los cambios, podemos borrar la rama y actualizar nuestro repositorio con los datos del remoto como hicimos antes. \u00bfPor qu\u00e9 actualizar desde el remoto y no desde nuetra rama add-license ? Pues porque usualmente el administrador puede haber modificado los cambios que le hemos propuesto, o incluso una tercera persona. Recordemos el cariz colaborativo que tiene Github. $ git checkout master $ git branch -d add-license # Esto borra la rama local $ git push origin --delete add-license # Esto borra la rama remota. Tambi\u00e9n puede hacerse desde la web.","title":"Creando nuevas funcionalidades"},{"location":"github-avanzado/#todo-esto-es-algo-complicado","text":"S\u00ed, lo es, al menos al principio. Git tiene una parte muy sencilla que es el uso del repositorio local (\u00f3rdenes tales como add, rm, mv y commit). El siguiente nivel de complejidad lo componen las \u00f3rdenes para trabajar con ramas y fusionarlas (checkout, branch, merge, rebase) y por \u00faltimo, las que trabajan con repositorios remotos (pull, push, fetch, remote). Adem\u00e1s hay otra serie de \u00f3rdenes para tener informaci\u00f3n (diff, log, status) o hacer operaciones de mantenimiento (fsck, gc). Lo importante para no perderse en Git, es seguir la siguiente m\u00e1xima: No avanzar al siguiente nivel de complejidad, hasta no haber entendido completamente el anterior. Muy poco sentido tiene ponernos a crear ramas en github si a\u00fan no entendemos c\u00f3mo se crean localmente y para que deben usarse. En la parte de referencias hay varios manuales en l\u00ednea, incluso tutoriales interactivos. Tambi\u00e9n hay mucha documentaci\u00f3n disponible en Github que suele venir muy bien explicada. En caso de que tengamos un problema que no sepamos resolver, una web muy buena es StackOverflow . Es una web de preguntas y respuestas para profesionales; es muy dif\u00edcil que se os plantee una duda que no haya sido ya preguntada y respondida en esa web. Eso s\u00ed, el ingl\u00e9s es imprescindible.","title":"Todo esto es algo complicado..."},{"location":"github-avanzado/#ultimo-paso-documentacion","text":"Github permite crear documentaci\u00f3n. En primer lugar, generando un archivo llamado README.md . Tambi\u00e9n permite crear una web propia para el proyecto y, adem\u00e1s, una wiki. Para marcar el texto, se utiliza un lenguaje de marcado de texto denominado Markdown . En la siguiente web hay un tutorial interactivo: http://www.markdowntutorial.com/ . Como en principio, no es necesario saber Markdown para poder trabajar con Git o con Github, no vamos a incidir m\u00e1s en este asunto. En el propio GitHub podemos encontrar algunas plantillas que nos sirvan de referencia. Algunos ejemplos: Plantilla b\u00e1sica Plantilla avanzada","title":"\u00daltimo paso, documentaci\u00f3n."},{"location":"github-avanzado/#documentacion-del-curso","text":"Esta documentaci\u00f3n est\u00e1 hecha en Markdown y pasada a HTML gracia a la herramienta mkdocs . La plantilla usada es Material for MkDocs . El material est\u00e1 publicado con licencia Atribuci\u00f3n-NoComercial 4.0 Internacional (CC BY-NC 4.0)","title":"Documentaci\u00f3n del curso"},{"location":"github-flow/","text":"Flujo de trabajo en GitHub \u00b6 Paso 0. Abrir una incidencia (issue) \u00b6 Habitualmente el trabajo puede partir a ra\u00edz de una reporte por parte de un miembro del equipo o de una persona externa. Para eso tenemos la secci\u00f3n Issues . Una issue cuando se crea se compone de un t\u00edtulo y una descripci\u00f3n en Markdown. Si la persona es miembro del equipo, opcionalmente puede asignarle una serie de metadatos: etiquetas (labels), hitos (milestone), proyecto al que pertenece o responsables encargados de cerrar la incidencia. Una vez creado, al mismo se le asignar\u00e1 un n\u00famero.\u00e7 Example Vamos a crear una incidencia llamada \"Crear archivo de autores\", donde indiquemos que vamos a crear un archivo AUTHORS.md con la lista de desarrolladores del proyecto. Paso 1. Crear una rama \u00b6 Crearemos una rama cada vez que queramos implementar una nueva caracter\u00edstica al proyecto que estamos realizando. La misma puede estar provocada por una incidencia o no. Tip Es una buena costumbre crear en Issues el listado de casos de uso, requisitos, hostorias de usuario o tareas (como lo queramos llamar), para tener un registro del trabajo que llevamos y el que nos queda. El nombre de la rama puede ser el que creamos conveniente, pero hay que intentar ser coherente y usar siempre el mismo m\u00e9todo, sobre todo si trabajamos en equipo. Un m\u00e9todo puede ser el siguiente: $ # tipo-n\u00famero/descripci\u00f3n $ git checkout -b feature-1/create-changelog $ git checkout -b hotfix-2/updated-database En entornos de trabajo multiusuario se puede usar el siguiente: $ # usuario/tipo-n\u00famero/descripci\u00f3n $ git checkout -b sgomez/feature-1/create-changelog $ git checkout -b sgomez/hotfix-2/updated-database De esa manera, podemos seguir f\u00e1cilmente qui\u00e9n abri\u00f3 la rama, en qu\u00e9 consiste y a qu\u00e9 issues est\u00e1 conectada. Pero como decimos es m\u00e1s un convenio que una imposici\u00f3n, pudi\u00e9ndole poner el nombre que queramos. Vamos a crear la rama y los commits correspondientes y subir la rama con push al servidor. $ git checkout -b sgomez/feature-1/create-changelog $ git add AUTHORS.md $ git commit -m \"A\u00f1adido fichero de autores\" El archivo puede contener, por ejemplo, lo siguiente: # AUTHORS * Sergio G\u00f3mez <sergio@uco.es> Hacemos push y obtenemos algo como esto: $ git push fatal: The current branch sgomez/feature-1/create-changelog has no upstream branch. To push the current branch and set the remote as upstream, use git push --set-upstream origin sgomez/feature-1/create-changelog Como la rama es nueva, git no sabe d\u00f3nde debe hacer push. Le indicamos que debe hacerla en origin y adem\u00e1s que guarde la vinculaci\u00f3n (equivalente al par\u00e1metro -u que vimos en el cap\u00edtulo anterior). Probamos de nuevo: $ git push -u origin sgomez/feature-1/create-changelog Enumerating objects: 4, done. Counting objects: 100% (4/4), done. Delta compression using up to 4 threads Compressing objects: 100% (2/2), done. Writing objects: 100% (3/3), 1.03 KiB | 1.03 MiB/s, done. Total 3 (delta 0), reused 0 (delta 0) remote: remote: Create a pull request for 'sgomez/feature-1/create-changelog' on GitHub by visiting: remote: https://github.com/sgomez/taller-de-git/pull/new/sgomez/feature-1/create-changelog remote: To github.com:sgomez/taller-de-git.git * [new branch] sgomez/feature-1/create-changelog -> sgomez/feature-1/create-changelog Branch 'sgomez/feature-1/create-changelog' set up to track remote branch 'sgomez/feature-1/create-changelog' from 'origin'. Ahora la rama ya se ha subido y nos informa, adem\u00e1s, de que podemos crear un Pull Request (PR). Si vamos al enlace que nos aparece veremos lo siguiente: Aqu\u00ed podemos informar de en qu\u00e9 consiste la rama que estamos enviando. Si ya tenemos una issue abierta, no es necesario repetir la misma informaci\u00f3n. Podemos hacer referencia con el siguiente texto: Closes #1 Esto lo que le indica a GitHub que esta PR cierra el issues n\u00famero 1. Cuando se haga el merge de la rama, autom\u00e1ticamente se cerrar\u00e1 la incidencia. Lo hacemos y le damos a crear. Paso 2. Crear commits \u00b6 A partir de ahora podemos seguir creando commits en local y enviarlos hasta que terminemos de trabajar. Editamos el archivo AUTHORS.md . # AUTHORS * Sergio G\u00f3mez <sergio@uco.es> * John Doe Y mandamos otro commit $ git commit -am \"Actualizado AUTHORS.md\" $ git push Si volvemos a la p\u00e1gina de PR, veremos que aparece el nuevo commit que acabamos de enviar. Paso 3. Discutir \u00b6 GitHub permite que entre los desarrolladores se pueda abrir una discusi\u00f3n sobre el c\u00f3digo, de tal manera que el trabajo de crear la rama sea colaborativo. Se puede incluso pedir revisiones por parte de terceros y que esas revisiones sean obligatorias antes de aceptar los cambios. Paso 4. Desplegar \u00b6 Una vez que hemos terminado de crear la funci\u00f3n de la rama ya podemos incorporar los cambios a master . Este trabajo ya no es necesario hacerlo en local y GitHub nos proporciona 3 maneras de hacerlo: Crear un merge commit \u00b6 Esta opci\u00f3n es el equivalente a hacer lo siguiente en nuestro repositorio: $ git checkout master $ git merge --no-ff sgomez/feature-1/create-changelog $ git push Es decir, el equivalente a hacer un merge entre nuestra rama y master. Info GitHub siempre desactiva el fast forward . Crear un rebase y merge \u00b6 Esta opci\u00f3n es el equivalente a hacer lo siguiente en nuestro repositorio $ git rebase master $ git checkout master $ git merge --no-ff sgomez/feature-1/create-changelog $ git push Es decir, nos aseguramos de que nuestra rama est\u00e1 al final de master haciendo rebase , como vimos en el cap\u00edtulo de ramas, y posteriormente se hace el merge. Crear un squash commit y un merge \u00b6 Esta opci\u00f3n es el equivalente a hacer lo siguiente en nuestro repositorio: $ git checkout master $ git merge --squash sgomez/feature-1/create-changelog $ git push Esta opci\u00f3n es algo especial. En vez de aplicar cada uno de los commits en la rama master, ya sea directamente ( fast forward ) o no, lo que hace es crear un solo commit con los cambios de todos los commits de la rama. El efecto final es como si en la rama solo hubiera producido un solo commit. Vamos a seleccionar este \u00faltimo (squash and merge) y le damos al bot\u00f3n para activarlo. Nos saldr\u00e1 una caja para que podamos crear una descripci\u00f3n del commit y le damos a confirmar. Ya hemos terminado y nos aparecer\u00e1 una opci\u00f3n para borrar la rama, lo m\u00e1s recomendado para no tener ramas obsoletas. Las consecuencias de esta acci\u00f3n son las siguientes: El PR aparecer\u00e1 como estado merged y en la lista de PR como cerrado. El issue que abrimos se habr\u00e1 cerrado autom\u00e1ticamente. En el listado de commits aparecer\u00e1 solo uno con un enlace al PR (en vez de los dos commits que hicimos). Paso 5. Sincronizar \u00b6 Hemos cambiado el repositorio en GitHub, pero nuestra rama master no contiene los mismos cambios que el de origin. As\u00ed que nos toca sincronizar y borrar la rama obsoleta: $ git checkout master $ git pull --rebase --autostash $ git branch -D sgomez/feature-1/create-changelog Info \u00bfPor qu\u00e9 squash and merge y no un merge o rebase ? De nuevo depende de los gustos de cada equipo de desarrollo. Las cracter\u00edsticas de squash es que elimina (relativamente) rastros de errores intermedios mientras se implementaba la rama, deja menos commits en la rama master y nos enlace al PR donde se implementaron los cambios. Para algunas personas estas caracter\u00edsticas son unas ventajas, para otras no. Lo mejor es experimentar cada opci\u00f3n y cada uno decida como quiere trabajar.","title":"Flujo de trabajo en GitHub"},{"location":"github-flow/#flujo-de-trabajo-en-github","text":"","title":"Flujo de trabajo en GitHub"},{"location":"github-flow/#paso-0-abrir-una-incidencia-issue","text":"Habitualmente el trabajo puede partir a ra\u00edz de una reporte por parte de un miembro del equipo o de una persona externa. Para eso tenemos la secci\u00f3n Issues . Una issue cuando se crea se compone de un t\u00edtulo y una descripci\u00f3n en Markdown. Si la persona es miembro del equipo, opcionalmente puede asignarle una serie de metadatos: etiquetas (labels), hitos (milestone), proyecto al que pertenece o responsables encargados de cerrar la incidencia. Una vez creado, al mismo se le asignar\u00e1 un n\u00famero.\u00e7 Example Vamos a crear una incidencia llamada \"Crear archivo de autores\", donde indiquemos que vamos a crear un archivo AUTHORS.md con la lista de desarrolladores del proyecto.","title":"Paso 0. Abrir una incidencia (issue)"},{"location":"github-flow/#paso-1-crear-una-rama","text":"Crearemos una rama cada vez que queramos implementar una nueva caracter\u00edstica al proyecto que estamos realizando. La misma puede estar provocada por una incidencia o no. Tip Es una buena costumbre crear en Issues el listado de casos de uso, requisitos, hostorias de usuario o tareas (como lo queramos llamar), para tener un registro del trabajo que llevamos y el que nos queda. El nombre de la rama puede ser el que creamos conveniente, pero hay que intentar ser coherente y usar siempre el mismo m\u00e9todo, sobre todo si trabajamos en equipo. Un m\u00e9todo puede ser el siguiente: $ # tipo-n\u00famero/descripci\u00f3n $ git checkout -b feature-1/create-changelog $ git checkout -b hotfix-2/updated-database En entornos de trabajo multiusuario se puede usar el siguiente: $ # usuario/tipo-n\u00famero/descripci\u00f3n $ git checkout -b sgomez/feature-1/create-changelog $ git checkout -b sgomez/hotfix-2/updated-database De esa manera, podemos seguir f\u00e1cilmente qui\u00e9n abri\u00f3 la rama, en qu\u00e9 consiste y a qu\u00e9 issues est\u00e1 conectada. Pero como decimos es m\u00e1s un convenio que una imposici\u00f3n, pudi\u00e9ndole poner el nombre que queramos. Vamos a crear la rama y los commits correspondientes y subir la rama con push al servidor. $ git checkout -b sgomez/feature-1/create-changelog $ git add AUTHORS.md $ git commit -m \"A\u00f1adido fichero de autores\" El archivo puede contener, por ejemplo, lo siguiente: # AUTHORS * Sergio G\u00f3mez <sergio@uco.es> Hacemos push y obtenemos algo como esto: $ git push fatal: The current branch sgomez/feature-1/create-changelog has no upstream branch. To push the current branch and set the remote as upstream, use git push --set-upstream origin sgomez/feature-1/create-changelog Como la rama es nueva, git no sabe d\u00f3nde debe hacer push. Le indicamos que debe hacerla en origin y adem\u00e1s que guarde la vinculaci\u00f3n (equivalente al par\u00e1metro -u que vimos en el cap\u00edtulo anterior). Probamos de nuevo: $ git push -u origin sgomez/feature-1/create-changelog Enumerating objects: 4, done. Counting objects: 100% (4/4), done. Delta compression using up to 4 threads Compressing objects: 100% (2/2), done. Writing objects: 100% (3/3), 1.03 KiB | 1.03 MiB/s, done. Total 3 (delta 0), reused 0 (delta 0) remote: remote: Create a pull request for 'sgomez/feature-1/create-changelog' on GitHub by visiting: remote: https://github.com/sgomez/taller-de-git/pull/new/sgomez/feature-1/create-changelog remote: To github.com:sgomez/taller-de-git.git * [new branch] sgomez/feature-1/create-changelog -> sgomez/feature-1/create-changelog Branch 'sgomez/feature-1/create-changelog' set up to track remote branch 'sgomez/feature-1/create-changelog' from 'origin'. Ahora la rama ya se ha subido y nos informa, adem\u00e1s, de que podemos crear un Pull Request (PR). Si vamos al enlace que nos aparece veremos lo siguiente: Aqu\u00ed podemos informar de en qu\u00e9 consiste la rama que estamos enviando. Si ya tenemos una issue abierta, no es necesario repetir la misma informaci\u00f3n. Podemos hacer referencia con el siguiente texto: Closes #1 Esto lo que le indica a GitHub que esta PR cierra el issues n\u00famero 1. Cuando se haga el merge de la rama, autom\u00e1ticamente se cerrar\u00e1 la incidencia. Lo hacemos y le damos a crear.","title":"Paso 1. Crear una rama"},{"location":"github-flow/#paso-2-crear-commits","text":"A partir de ahora podemos seguir creando commits en local y enviarlos hasta que terminemos de trabajar. Editamos el archivo AUTHORS.md . # AUTHORS * Sergio G\u00f3mez <sergio@uco.es> * John Doe Y mandamos otro commit $ git commit -am \"Actualizado AUTHORS.md\" $ git push Si volvemos a la p\u00e1gina de PR, veremos que aparece el nuevo commit que acabamos de enviar.","title":"Paso 2. Crear commits"},{"location":"github-flow/#paso-3-discutir","text":"GitHub permite que entre los desarrolladores se pueda abrir una discusi\u00f3n sobre el c\u00f3digo, de tal manera que el trabajo de crear la rama sea colaborativo. Se puede incluso pedir revisiones por parte de terceros y que esas revisiones sean obligatorias antes de aceptar los cambios.","title":"Paso 3. Discutir"},{"location":"github-flow/#paso-4-desplegar","text":"Una vez que hemos terminado de crear la funci\u00f3n de la rama ya podemos incorporar los cambios a master . Este trabajo ya no es necesario hacerlo en local y GitHub nos proporciona 3 maneras de hacerlo:","title":"Paso 4. Desplegar"},{"location":"github-flow/#crear-un-merge-commit","text":"Esta opci\u00f3n es el equivalente a hacer lo siguiente en nuestro repositorio: $ git checkout master $ git merge --no-ff sgomez/feature-1/create-changelog $ git push Es decir, el equivalente a hacer un merge entre nuestra rama y master. Info GitHub siempre desactiva el fast forward .","title":"Crear un merge commit"},{"location":"github-flow/#crear-un-rebase-y-merge","text":"Esta opci\u00f3n es el equivalente a hacer lo siguiente en nuestro repositorio $ git rebase master $ git checkout master $ git merge --no-ff sgomez/feature-1/create-changelog $ git push Es decir, nos aseguramos de que nuestra rama est\u00e1 al final de master haciendo rebase , como vimos en el cap\u00edtulo de ramas, y posteriormente se hace el merge.","title":"Crear un rebase y merge"},{"location":"github-flow/#crear-un-squash-commit-y-un-merge","text":"Esta opci\u00f3n es el equivalente a hacer lo siguiente en nuestro repositorio: $ git checkout master $ git merge --squash sgomez/feature-1/create-changelog $ git push Esta opci\u00f3n es algo especial. En vez de aplicar cada uno de los commits en la rama master, ya sea directamente ( fast forward ) o no, lo que hace es crear un solo commit con los cambios de todos los commits de la rama. El efecto final es como si en la rama solo hubiera producido un solo commit. Vamos a seleccionar este \u00faltimo (squash and merge) y le damos al bot\u00f3n para activarlo. Nos saldr\u00e1 una caja para que podamos crear una descripci\u00f3n del commit y le damos a confirmar. Ya hemos terminado y nos aparecer\u00e1 una opci\u00f3n para borrar la rama, lo m\u00e1s recomendado para no tener ramas obsoletas. Las consecuencias de esta acci\u00f3n son las siguientes: El PR aparecer\u00e1 como estado merged y en la lista de PR como cerrado. El issue que abrimos se habr\u00e1 cerrado autom\u00e1ticamente. En el listado de commits aparecer\u00e1 solo uno con un enlace al PR (en vez de los dos commits que hicimos).","title":"Crear un squash commit y un merge"},{"location":"github-flow/#paso-5-sincronizar","text":"Hemos cambiado el repositorio en GitHub, pero nuestra rama master no contiene los mismos cambios que el de origin. As\u00ed que nos toca sincronizar y borrar la rama obsoleta: $ git checkout master $ git pull --rebase --autostash $ git branch -D sgomez/feature-1/create-changelog Info \u00bfPor qu\u00e9 squash and merge y no un merge o rebase ? De nuevo depende de los gustos de cada equipo de desarrollo. Las cracter\u00edsticas de squash es que elimina (relativamente) rastros de errores intermedios mientras se implementaba la rama, deja menos commits en la rama master y nos enlace al PR donde se implementaron los cambios. Para algunas personas estas caracter\u00edsticas son unas ventajas, para otras no. Lo mejor es experimentar cada opci\u00f3n y cada uno decida como quiere trabajar.","title":"Paso 5. Sincronizar"},{"location":"github-zenodo/","text":"Citar proyectos en GitHub \u00b6 Extra\u00eddo de la gu\u00eda oficial de GitHub . A trav\u00e9s de una aplicaci\u00f3n de terceros (Zenodo, financiado por el CERN), es posible crear un DOI para uno de nuestros proyectos. Estos son los pasos Paso 1. Elegir un repositorio \u00b6 Este repositorio debe ser abierto (p\u00fablico), o de lo contrario Zenodo no podr\u00e1 acceder al mismo. Hay que recordar escoger una licencia para el proyecto. Esta web puede ayudarnos http://choosealicense.com/ . Paso 2. Entrar en Zenodo \u00b6 Iremos a Zenodo y haremos login con GitHub. Lo \u00fanico que tenemos que hacer en esta parte es autorizar a Zenodo a conectar con nuestra cuenta de GitHub. Important Si deseas archivar un repositorio que pertenece a una organizaci\u00f3n en GitHub, deber\u00e1s asegurarte de que el administrador de la organizaci\u00f3n haya habilitado el acceso de terceros a la aplicaci\u00f3n Zenodo. Paso 3. Seleccionar los repositorios \u00b6 En este punto, hemos autorizado a Zenodo para configurar los permisos necesarios para permitir el archivado y la emisi\u00f3n del DOI. Para habilitar esta funcionalidad, simplemente haremo clic en el bot\u00f3n que est\u00e1 junto a cada uno de los repositorios que queremos archivar. Important Zenodo solo puede acceder a los repositorios p\u00fablicos, as\u00ed que debemos asegurarnos de que el repositorio que deseamos archivar sea p\u00fablico. Paso 4. Crear una nueva release \u00b6 Por defecto, Zenodo realiza un archivo de nuestro repositorio de GitHub cada vez que crea una nueva versi\u00f3n. Como a\u00fan no tenemos ninguna, tenemos que volver a la vista del repositorio principal y hacer clic en el elemento del encabezado de versiones ( releases ). Paso 5. Acu\u00f1ar un DOI \u00b6 Antes de que Zenodo pueda emitir un DOI para nuestro repositorio, deberemos proporcionar cierta informaci\u00f3n sobre el repositorio de GitHub que acaba de archivar. Una vez que estemos satisfechos con la descripci\u00f3n, heremos clic en el bot\u00f3n publicar. Paso 6. Publicar \u00b6 De vuelta a nuestra p\u00e1gina de Zenodo, ahora deber\u00edamos ver el repositorio listado con una nueva insignia que muestra nuestro nuevo DOI. Tip Podemos colocar la insigna en nuestro proyecto. Para eso haremos clic en la imagen DOI gris y azul. Se abrir\u00e1 una ventana emergente y el texto que aparece como Markdown es el que deberemos copiar en nuestro archivo README.md .","title":"Citar proyectos en GitHub"},{"location":"github-zenodo/#citar-proyectos-en-github","text":"Extra\u00eddo de la gu\u00eda oficial de GitHub . A trav\u00e9s de una aplicaci\u00f3n de terceros (Zenodo, financiado por el CERN), es posible crear un DOI para uno de nuestros proyectos. Estos son los pasos","title":"Citar proyectos en GitHub"},{"location":"github-zenodo/#paso-1-elegir-un-repositorio","text":"Este repositorio debe ser abierto (p\u00fablico), o de lo contrario Zenodo no podr\u00e1 acceder al mismo. Hay que recordar escoger una licencia para el proyecto. Esta web puede ayudarnos http://choosealicense.com/ .","title":"Paso 1. Elegir un repositorio"},{"location":"github-zenodo/#paso-2-entrar-en-zenodo","text":"Iremos a Zenodo y haremos login con GitHub. Lo \u00fanico que tenemos que hacer en esta parte es autorizar a Zenodo a conectar con nuestra cuenta de GitHub. Important Si deseas archivar un repositorio que pertenece a una organizaci\u00f3n en GitHub, deber\u00e1s asegurarte de que el administrador de la organizaci\u00f3n haya habilitado el acceso de terceros a la aplicaci\u00f3n Zenodo.","title":"Paso 2. Entrar en Zenodo"},{"location":"github-zenodo/#paso-3-seleccionar-los-repositorios","text":"En este punto, hemos autorizado a Zenodo para configurar los permisos necesarios para permitir el archivado y la emisi\u00f3n del DOI. Para habilitar esta funcionalidad, simplemente haremo clic en el bot\u00f3n que est\u00e1 junto a cada uno de los repositorios que queremos archivar. Important Zenodo solo puede acceder a los repositorios p\u00fablicos, as\u00ed que debemos asegurarnos de que el repositorio que deseamos archivar sea p\u00fablico.","title":"Paso 3. Seleccionar los repositorios"},{"location":"github-zenodo/#paso-4-crear-una-nueva-release","text":"Por defecto, Zenodo realiza un archivo de nuestro repositorio de GitHub cada vez que crea una nueva versi\u00f3n. Como a\u00fan no tenemos ninguna, tenemos que volver a la vista del repositorio principal y hacer clic en el elemento del encabezado de versiones ( releases ).","title":"Paso 4. Crear una nueva release"},{"location":"github-zenodo/#paso-5-acunar-un-doi","text":"Antes de que Zenodo pueda emitir un DOI para nuestro repositorio, deberemos proporcionar cierta informaci\u00f3n sobre el repositorio de GitHub que acaba de archivar. Una vez que estemos satisfechos con la descripci\u00f3n, heremos clic en el bot\u00f3n publicar.","title":"Paso 5. Acu\u00f1ar un DOI"},{"location":"github-zenodo/#paso-6-publicar","text":"De vuelta a nuestra p\u00e1gina de Zenodo, ahora deber\u00edamos ver el repositorio listado con una nueva insignia que muestra nuestro nuevo DOI. Tip Podemos colocar la insigna en nuestro proyecto. Para eso haremos clic en la imagen DOI gris y azul. Se abrir\u00e1 una ventana emergente y el texto que aparece como Markdown es el que deberemos copiar en nuestro archivo README.md .","title":"Paso 6. Publicar"},{"location":"github/","text":"Github \u00b6 Github es lo que se denomina una forja, un repositorio de proyectos que usan Git como sistema de control de versiones. Es la forja m\u00e1s popular, ya que alberga m\u00e1s de 10 millones de repositorios. Debe su popularidad a sus funcionalidades sociales, principalmente dos: la posibilidad de hacer forks de otros proyectos y la posibilidad de cooperar aportando c\u00f3digo para arreglar errores o mejorar el c\u00f3digo. Si bien, no es que fuera una novedad, s\u00ed lo es lo f\u00e1cil que resulta hacerlo. A ra\u00edz de este proyecto han surgido otros como Gitorius o Gitlab , pero Github sigue siendo el m\u00e1s popular y el que tiene mejores y mayores caracter\u00edsticas. algunas de estas son: Un wiki para documentar el proyecto, que usa MarkDown como lenguaje de marca. Un portal web para cada proyecto. Funcionalidades de redes sociales como followers. Gr\u00e1ficos estad\u00edsticos. Revisi\u00f3n de c\u00f3digo y comentarios. Sistemas de seguimiento de incidencias. Lo primero es entrar en el portal ( https://github.com/ ) para crearnos una cuenta si no la tenemos a\u00fan. Tu clave p\u00fablica/privada \u00b6 Muchos servidores Git utilizan la autentificaci\u00f3n a trav\u00e9s de claves p\u00fablicas SSH. Y, para ello, cada usuario del sistema ha de generarse una, si es que no la tiene ya. El proceso para hacerlo es similar en casi cualquier sistema operativo. Ante todo, asegurarte que no tengas ya una clave. (comprueba que el directorio $HOME/usuario/.ssh no tiene un archivo id_dsa.pub o id_rsa.pub). Para crear una nueva clave usamos la siguiente orden: $ ssh-keygen -t rsa -C \"Cuenta Thinstation\" Warning Tu clave RSA te identifica contra los repositorios remotos, aseg\u00farate de no compartir la clave privada con nadie. Por defecto la clave se crea como solo lectura . Configuraci\u00f3n \u00b6 Vamos a aprovechar para a\u00f1adir la clave RSA que generamos antes, para poder acceder desde git a los repositorios. Para ellos nos vamos al men\u00fa de configuraci\u00f3n de usuario ( Settings ) Nos vamos al men\u00fa 'SSH and GPG Keys' y a\u00f1adimos una nueva clave. En Title indicamos una descripci\u00f3n que nos ayude a saber de d\u00f3nde procede la clave y en key volcamos el contenido del archivo ~/.ssh/id_rsa.pub . Y guardamos la clave. Con esto ya tendriamos todo nuestro entorno para poder empezar a trabajar desde nuestro equipo. Clientes gr\u00e1ficos para GitHub \u00b6 Adem\u00e1s, para Github existe un cliente propio tanto para Windows como para MacOSX: Cliente Windows: http://windows.github.com/ Cliente MacOSX: http://mac.github.com/ Para Linux no hay cliente propio, pero s\u00ed hay plugin para la mayor\u00eda de editores de texto como atom, netbeans, eclipe o los editores de jetbrains. De todas maneras, estos clientes solo tienen el fin de facilitar el uso de Github, pero no son necesarios para usarlo. Es perfectamente v\u00e1lido usar el cliente de consola de Git o cualquier otro cliente gen\u00e9rico para Git. Uno de los m\u00e1s usados actualmente es GitKraken . Crear un repositorio \u00b6 Vamos a crear un repositorio donde guardar nuestro proyecto. Para ello pulsamos el signo + que hay en la barra superior y seleccionamos New repository . Ahora tenemos que designar un nombre para nuestro repositorio, por ejemplo: ' taller-de-git '. Nada m\u00e1s crear el repositorio nos saldr\u00e1 una pantalla con instrucciones precisas de como proceder a continuaci\u00f3n. B\u00e1sicamente podemos partir de tres situaciones: Todav\u00eda no hemos creado ning\u00fan repositorio en nuestro equipo. Ya tenemos un repositorio creado y queremos sincronizarlo con Github. Queremos importar un repositorio de otro sistema de control de versiones distinto. Nuestra situaci\u00f3n es la segunda, as\u00ed que nos aseguramos de que hemos elegido SSH como protocolo. A continuaci\u00f3n pulsamos el icono del portapapeles y ejecutamos las dos ordenes que nos indica la web en nuestro terminal. $ git remote add origin git@github.com:sgomez/taller-de-git.git $ git push -u origin master Counting objects: 33, done. Delta compression using up to 4 threads. Compressing objects: 100% (24/24), done. Writing objects: 100% (33/33), 3.35 KiB | 1.12 MiB/s, done. Total 33 (delta 2), reused 0 (delta 0) remote: Resolving deltas: 100% (2/2), done. To github.com:sgomez/taller-de-git.git * [new branch] master -> master Branch master set up to track remote branch master from origin by rebasing. Si recargamos la p\u00e1gina veremos que ya aparece nuestro proyecto. Clonar un repositorio \u00b6 Una vez que ya tengamos sincronizado el repositorio contra Github, eventualmente vamos a querer descargarlo en otro de nuestros ordenadores para poder trabajar en \u00e9l. Esta acci\u00f3n se denomina clonar y para ello usaremos la orden git clone . En la p\u00e1gina principal de nuestro proyecto podemos ver un bot\u00f3n que indica Clone or download . Si la pulsamos nos da, de nuevo, la opci\u00f3n de elegir entre clonar con ssh o https . Recordad que si est\u00e1is en otro equipo y quer\u00e9is seguir utilizando ssh deber\u00e9is generar otra para de claves privada/p\u00fablica como hicimos en la secci\u00f3n de Aspectos b\u00e1sicos de Git y instalarla en nuestro perfil de Github, como vimos anteriormente. Para clonar nuestro repositorio y poder trabajar con \u00e9l todo lo que debemos hacer es lo siguiente: $ git clone git@github.com:sgomez/taller-de-git.git $ cd taller-de-git Ramas remotas \u00b6 Si ahora vemos el estado de nuestro proyecto veremos algo similar a esto: $ git hist --all * 2eab8ca 2013-06-16 | Aplicando los cambios de la rama hola (HEAD -> master, origin/master) [Sergio Gomez] *\\ | * 9862f33 2013-06-16 | hola usa la clase HolaMundo (hola) [Sergio G\u00f3mez] | * 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez] |/ * 9c85275 2013-06-16 | Programa interactivo (master) [Sergio G\u00f3mez] * c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez] * 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez] * 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez] * fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez] * 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez] * efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez] * e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez] Aparece que hay una nueva rama llamada origin/master . Esta rama indica el estado de sincronizaci\u00f3n de nuestro repositorio con un repositorio remoto llamado origin . En este caso el de Github . Info Por norma se llama autom\u00e1ticamente origin al primer repositorio con el que sincronizamos nuestro repositorio. Podemos ver la configuraci\u00f3n de este repositorio remoto con la orden git remote : $ git remote show origin * remote origin Fetch URL: git@github.com:sgomez/taller-de-git.git Push URL: git@github.com:sgomez/taller-de-git.git HEAD branch: master Remote branch: master tracked Local ref configured for 'git push': master pushes to master (up to date) De la respuesta tenemos que fijarnos en las l\u00edneas que indican fetch y push puesto que son las acciones de sincronizaci\u00f3n de nuestro repositorio con el remoto. Mientras que fetch se encarga de traer los cambios desde el repositorio remoto al nuestro, push los env\u00eda. Enviando actualizaciones \u00b6 Vamos a a\u00f1adir una licencia a nuestra aplicaci\u00f3n. Creamos un fichero LICENSE con el siguiente contenido: MIT License Copyright (c) [year] [fullname] Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. Y a\u00f1adidos y confirmamos los cambios: $ git add LICENSE $ git commit -m \"A\u00f1adida licencia\" [master 3f5cb1c] A\u00f1adida licencia 1 file changed, 21 insertions(+) create mode 100644 LICENSE $ git hist --all * 3f5cb1c 2013-06-16 | A\u00f1adida licencia (HEAD -> master) [Sergio G\u00f3mez] * 2eab8ca 2013-06-16 | Aplicando los cambios de la rama hola (origin/master) [Sergio Gomez] *\\ | * 9862f33 2013-06-16 | hola usa la clase HolaMundo (hola) [Sergio G\u00f3mez] | * 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez] |/ * 9c85275 2013-06-16 | Programa interactivo (master) [Sergio G\u00f3mez] * c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez] * 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez] * 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez] * fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez] * 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez] * efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez] * e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez] Viendo la historia podemos ver como nuestro master no est\u00e1 en el mismo punto que origin/master . Si vamos a la web de Github veremos que LICENSE no aparece a\u00fan. As\u00ed que vamos a enviar los cambios con la primera de las acciones que vimos git push : $ git push -u origin master Counting objects: 3, done. Delta compression using up to 4 threads. Compressing objects: 100% (3/3), done. Writing objects: 100% (3/3), 941 bytes | 0 bytes/s, done. Total 3 (delta 0), reused 0 (delta 0) To git@github.com:sgomez/taller-de-git.git 2eab8ca..3f5cb1c master -> master Branch master set up to track remote branch master from origin. Info La orden git push necesita dos par\u00e1metros para funcionar: el repositorio y la rama destino. As\u00ed que realmente lo que ten\u00edamos que haber escrito es: $ git push origin master Para ahorrar tiempo escribiendo git nos deja vincular nuestra rama local con una rama remota, de tal manera que no tengamos que estar siempre indic\u00e1ndolo. Eso es posible con el par\u00e1metro --set-upstream o -u en forma abreviada. $ git push -u origin master Si repasas las \u00f3rdenes que te indic\u00f3 Github que ejecutaras ver\u00e1s que el par\u00e1metro -u estaba presente y por eso no ha sido necesario indicar ning\u00fan par\u00e1metro al hacer push. Recibiendo actualizaciones \u00b6 Si trabajamos con m\u00e1s personas, o trabajamos desde dos ordenadores distintos, nos encontraremos con que nuestro repositorio local es m\u00e1s antiguo que el remoto. Necesitamos descargar los cambios para poder incorporarlos a nuestro directorio de trabajo. Para la prueba, Github nos permite editar archivos directamente desde la web. Pulsamos sobre el archivo README.md . En la vista del archivo, veremos que aparece el icono de un l\u00e1piz. Esto nos permite editar el archivo. Info Los archivos con extensi\u00f3n .md est\u00e1n en un formato denominado MarkDown . Se trata de un lenguaje de marca que nos permite escribir texto enriquecido de manera muy sencilla. Dispones de un tutorial aqu\u00ed: https://www.markdowntutorial.com/ Modificamos el archivo como queramos, por ejemplo, a\u00f1adiendo nuestro nombre: # Curso de GIT Este proyecto contiene el curso de introducci\u00f3n a GIT Desarrollado por Sergio G\u00f3mez. El cambio quedar\u00e1 incorporado al repositorio de Github, pero no al nuestro. Necesitamos traer la informaci\u00f3n desde el servidor remoto. La orden asociada es git fetch : $ git fetch $ git hist --all * cbaf831 2013-06-16 | Actualizado README.md (origin/master) [Sergio G\u00f3mez] * 3f5cb1c 2013-06-16 | A\u00f1adida licencia (HEAD -> master) [Sergio G\u00f3mez] * 2eab8ca 2013-06-16 | Aplicando los cambios de la rama hola [Sergio Gomez] *\\ | * 9862f33 2013-06-16 | hola usa la clase HolaMundo (hola) [Sergio G\u00f3mez] | * 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez] |/ * 9c85275 2013-06-16 | Programa interactivo (master) [Sergio G\u00f3mez] * c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez] * 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez] * 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez] * fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez] * 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez] * efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez] * e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez] Ahora vemos el caso contrario, tenemos que origin/master est\u00e1 por delante que HEAD y que la rama master local. Ahora necesitamos incorporar los cambios de la rama remota en la local. La forma de hacerlo lo vimos en el cap\u00edtulo anterior usando git merge o git rebase . Habitualmente se usa git merge : $ git merge origin/master Updating 3f5cb1c..cbaf831 Fast-forward README.md | 2 ++ 1 file changed, 2 insertions(+) $ git hist --all * cbaf831 2013-06-16 | Actualizado README.md (HEAD -> master, origin/master) [Sergio G\u00f3mez] * 3f5cb1c 2013-06-16 | A\u00f1adida licencia [Sergio G\u00f3mez] * 2eab8ca 2013-06-16 | Aplicando los cambios de la rama hola [Sergio Gomez] *\\ | * 9862f33 2013-06-16 | hola usa la clase HolaMundo (hola) [Sergio G\u00f3mez] | * 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez] |/ * 9c85275 2013-06-16 | Programa interactivo (master) [Sergio G\u00f3mez] * c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez] * 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez] * 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez] * fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez] * 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez] * efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez] * e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez] Como las operaciones de traer cambios ( git fetch ) y de mezclar ramas ( git merge o git rebase ) est\u00e1n muy asociadas, git nos ofrece una posibilidad para ahorrar pasos que es la orden git pull que realiza las dos acciones simult\u00e1neamente. Para probar, vamos a editar de nuevo el archivo README.md y a\u00f1adimos algo m\u00e1s: # Curso de GIT Este proyecto contiene el curso de introducci\u00f3n a GIT del Aula de Software Libre. Desarrollado por Sergio G\u00f3mez. Como mensaje del commit : 'Indicado que se realiza en el ASL' . Y ahora probamos a actualizar con git pull : $ git pull remote: Counting objects: 3, done. remote: Compressing objects: 100% (3/3), done. remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 Unpacking objects: 100% (3/3), done. From github.com:sgomez/taller-de-git cbaf831..d8922e4 master -> origin/master First, rewinding head to replay your work on top of it... Fast-forwarded master to d8922e4ffa4f87553b03e77df6196b7e496bfec4. $ git hist --all * d8922e4 2013-06-16 | Indicado que se realiza en el ASL (HEAD -> master, origin/master) [Sergio G\u00f3mez] * cbaf831 2013-06-16 | Actualizado README.md [Sergio G\u00f3mez] * 3f5cb1c 2013-06-16 | A\u00f1adida licencia [Sergio G\u00f3mez] * 2eab8ca 2013-06-16 | Aplicando los cambios de la rama hola [Sergio Gomez] *\\ | * 9862f33 2013-06-16 | hola usa la clase HolaMundo (hola) [Sergio G\u00f3mez] | * 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez] |/ * 9c85275 2013-06-16 | Programa interactivo (master) [Sergio G\u00f3mez] * c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez] * 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez] * 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez] * fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez] * 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez] * efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez] * e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez] Vemos que los cambios se han incorporado y que las ramas remota y local de master est\u00e1n sincronizadas. Problemas de sincronizaci\u00f3n \u00b6 No puedo hacer push \u00b6 Al intentar subir cambios nos podemos encontrar un mensaje como este: $ git push git push To git@github.com:sgomez/taller-de-git.git ! [rejected] master -> master (fetch first) error: failed to push some refs to 'git@github.com:sgomez/taller-de-git.git' hint: Updates were rejected because the remote contains work that you do hint: not have locally. This is usually caused by another repository pushing hint: to the same ref. You may want to first integrate the remote changes hint: (e.g., 'git pull ...') before pushing again. hint: See the 'Note about fast-forwards' in 'git push --help' for details. La causa es que el repositorio remoto tambi\u00e9n se ha actualizado y nosotros a\u00fan no hemos recibido esos cambios. Es decir, ambos repositorios se han actualizado y el remoto tiene preferencia. Hay un conflicto en ciernes y se debe resolver localmente antes de continuar. Vamos a provocar una situaci\u00f3n donde podamos ver esto en acci\u00f3n. Vamos a modificar el archivo README.md tanto en local como en remoto a trav\u00e9s del interfaz web. En el web vamos a cambiar el t\u00edtulo para que aparezca de la siguiente manera. Curso de GIT, 2020 En local vamos a cambiar el t\u00edtulo para que aparezca de la siguiente manera. Curso de GIT, febrero Question Haz el commit para guardar el cambio en local. ??? example \"Respuesta al ejercicio anterior\" A\u00f1adimos el fichero actualizado: $ git commit -am \"A\u00f1adido el mes al README\" [master 1e8c0b7] A\u00f1adido el mes al README 1 file changed, 1 insertion(+), 1 deletion(-) La forma de proceder en este caso es hacer un git fetch y un git rebase . Si hay conflictos deber\u00e1n resolverse. Cuando est\u00e9 todo solucionado ya podremos hacer git push . Info Por defecto git pull lo que hace es un git merge , si queremos hacer git rebase deberemos especificarlos con el par\u00e1metro -r : $ git pull --rebase Vamos a hacer el pull con rebase y ver qu\u00e9 sucede. $ git pull --rebase First, rewinding head to replay your work on top of it... Applying: A\u00f1adido el mes al README Using index info to reconstruct a base tree... M README.md Falling back to patching base and 3-way merge... Auto-merging README.md CONFLICT (content): Merge conflict in README.md error: Failed to merge in the changes. Patch failed at 0001 A\u00f1adido el mes al README hint: Use 'git am --show-current-patch' to see the failed patch Resolve all conflicts manually, mark them as resolved with \"git add/rm <conflicted_files>\", then run \"git rebase --continue\". You can instead skip this commit: run \"git rebase --skip\". To abort and get back to the state before \"git rebase\", run \"git rebase --abort\". Evidentemente hay un conflicto porque hemos tocado el mismo archivo. Se deja como ejercicio resolverlo. ??? example \"Respuesta al ejercicio anterior\" El contenido del fichero final podr\u00eda ser: Curso de GIT, febrero, 2020 A continuaci\u00f3n confirmamos los cambios y los enviamos al servidor $ git add README.md $ git rebase --continue $ git push Warning \u00bfPor qu\u00e9 hemos hecho rebase en master si a lo largo del curso hemos dicho que no se debe cambiar la linea principal? B\u00e1sicamente hemos dicho que lo que no debemos hacer es modificar la l\u00ednea temporal compartida . En este caso nuestros cambios en master solo estaban en nuestro repositorio, porque al fallar el env\u00edo nadie m\u00e1s ha visto nuestras actualizaciones. Al hacer rebase estamos deshaciendo nuestros cambios, bajarnos la \u00faltima actualizaci\u00f3n compartida de master y volvi\u00e9ndolos a aplicar. Con lo que realmente la historia compartida no se ha modificado. Este es un problema que debemos evitar en la medida de lo posible. La menor cantidad de gente posible debe tener acceso de escritura en master y las actualizaciones de dicha rama deben hacerse a trav\u00e9s de ramas secundarias y haciendo merge en master como hemos visto en el cap\u00edtulo de ramas. No puedo hacer pull \u00b6 Al intentar descargar cambios nos podemos encontrar un mensaje como este: $ git pull error: Cannot pull with rebase: You have unstaged changes. O como este: $ git pull error: Cannot pull with rebase: Your index contains uncommitted changes. B\u00e1sicamente lo que ocurre es que tenemos cambios sin confirmar en nuestro espacio de trabajo. Una opci\u00f3n es confirmar ( commit ) y entonces proceder como el caso anterior. Pero puede ocurrir que a\u00fan estemos trabajando todav\u00eda y no nos interese confirmar los cambios, solo queremos sincronizar y seguir trabajando. Para casos como estos git ofrece una pila para guardar cambios temporalmente. Esta pila se llama stash y nos permite restaurar el espacio de trabajo al \u00faltimo commit. De nuevo vamos a modificar nuestro proyecto para ver esta situaci\u00f3n en acci\u00f3n. Example En remoto borra el a\u00f1o de la fecha y en local borra el mes. Pero esta vez no hagas commit en local . El archivo solo debe quedar modificado. La forma de proceder es la siguiente: $ git stash save # Guardamos los cambios en la pila $ git pull # Sincronizamos con el repositorio remoto, -r para hacer rebase puede ser requerido $ git stash pop # Sacamos los cambios de la pila Info Como ocurre habitualmente, git nos proporciona una forma de hacer todos estos pasos de una sola vez. Para ello tenemos que ejecutar lo siguiente: $ git pull --autostash En general no es mala idea ejecutar lo siguiente si somos conscientes, adem\u00e1s, de que tenemos varios cambios sin sincronizar: $ git pull --autostash --rebase Podr\u00eda darse el caso de que al sacar los cambios de la pila hubiera alg\u00fan conflicto. En ese caso actuamos como con el caso de merge o rebase . De nuevo este tipo de problemas no deben suceder si nos acostumbramos a trabajar en ramas.","title":"Github"},{"location":"github/#github","text":"Github es lo que se denomina una forja, un repositorio de proyectos que usan Git como sistema de control de versiones. Es la forja m\u00e1s popular, ya que alberga m\u00e1s de 10 millones de repositorios. Debe su popularidad a sus funcionalidades sociales, principalmente dos: la posibilidad de hacer forks de otros proyectos y la posibilidad de cooperar aportando c\u00f3digo para arreglar errores o mejorar el c\u00f3digo. Si bien, no es que fuera una novedad, s\u00ed lo es lo f\u00e1cil que resulta hacerlo. A ra\u00edz de este proyecto han surgido otros como Gitorius o Gitlab , pero Github sigue siendo el m\u00e1s popular y el que tiene mejores y mayores caracter\u00edsticas. algunas de estas son: Un wiki para documentar el proyecto, que usa MarkDown como lenguaje de marca. Un portal web para cada proyecto. Funcionalidades de redes sociales como followers. Gr\u00e1ficos estad\u00edsticos. Revisi\u00f3n de c\u00f3digo y comentarios. Sistemas de seguimiento de incidencias. Lo primero es entrar en el portal ( https://github.com/ ) para crearnos una cuenta si no la tenemos a\u00fan.","title":"Github"},{"location":"github/#tu-clave-publicaprivada","text":"Muchos servidores Git utilizan la autentificaci\u00f3n a trav\u00e9s de claves p\u00fablicas SSH. Y, para ello, cada usuario del sistema ha de generarse una, si es que no la tiene ya. El proceso para hacerlo es similar en casi cualquier sistema operativo. Ante todo, asegurarte que no tengas ya una clave. (comprueba que el directorio $HOME/usuario/.ssh no tiene un archivo id_dsa.pub o id_rsa.pub). Para crear una nueva clave usamos la siguiente orden: $ ssh-keygen -t rsa -C \"Cuenta Thinstation\" Warning Tu clave RSA te identifica contra los repositorios remotos, aseg\u00farate de no compartir la clave privada con nadie. Por defecto la clave se crea como solo lectura .","title":"Tu clave p\u00fablica/privada"},{"location":"github/#configuracion","text":"Vamos a aprovechar para a\u00f1adir la clave RSA que generamos antes, para poder acceder desde git a los repositorios. Para ellos nos vamos al men\u00fa de configuraci\u00f3n de usuario ( Settings ) Nos vamos al men\u00fa 'SSH and GPG Keys' y a\u00f1adimos una nueva clave. En Title indicamos una descripci\u00f3n que nos ayude a saber de d\u00f3nde procede la clave y en key volcamos el contenido del archivo ~/.ssh/id_rsa.pub . Y guardamos la clave. Con esto ya tendriamos todo nuestro entorno para poder empezar a trabajar desde nuestro equipo.","title":"Configuraci\u00f3n"},{"location":"github/#clientes-graficos-para-github","text":"Adem\u00e1s, para Github existe un cliente propio tanto para Windows como para MacOSX: Cliente Windows: http://windows.github.com/ Cliente MacOSX: http://mac.github.com/ Para Linux no hay cliente propio, pero s\u00ed hay plugin para la mayor\u00eda de editores de texto como atom, netbeans, eclipe o los editores de jetbrains. De todas maneras, estos clientes solo tienen el fin de facilitar el uso de Github, pero no son necesarios para usarlo. Es perfectamente v\u00e1lido usar el cliente de consola de Git o cualquier otro cliente gen\u00e9rico para Git. Uno de los m\u00e1s usados actualmente es GitKraken .","title":"Clientes gr\u00e1ficos para GitHub"},{"location":"github/#crear-un-repositorio","text":"Vamos a crear un repositorio donde guardar nuestro proyecto. Para ello pulsamos el signo + que hay en la barra superior y seleccionamos New repository . Ahora tenemos que designar un nombre para nuestro repositorio, por ejemplo: ' taller-de-git '. Nada m\u00e1s crear el repositorio nos saldr\u00e1 una pantalla con instrucciones precisas de como proceder a continuaci\u00f3n. B\u00e1sicamente podemos partir de tres situaciones: Todav\u00eda no hemos creado ning\u00fan repositorio en nuestro equipo. Ya tenemos un repositorio creado y queremos sincronizarlo con Github. Queremos importar un repositorio de otro sistema de control de versiones distinto. Nuestra situaci\u00f3n es la segunda, as\u00ed que nos aseguramos de que hemos elegido SSH como protocolo. A continuaci\u00f3n pulsamos el icono del portapapeles y ejecutamos las dos ordenes que nos indica la web en nuestro terminal. $ git remote add origin git@github.com:sgomez/taller-de-git.git $ git push -u origin master Counting objects: 33, done. Delta compression using up to 4 threads. Compressing objects: 100% (24/24), done. Writing objects: 100% (33/33), 3.35 KiB | 1.12 MiB/s, done. Total 33 (delta 2), reused 0 (delta 0) remote: Resolving deltas: 100% (2/2), done. To github.com:sgomez/taller-de-git.git * [new branch] master -> master Branch master set up to track remote branch master from origin by rebasing. Si recargamos la p\u00e1gina veremos que ya aparece nuestro proyecto.","title":"Crear un repositorio"},{"location":"github/#clonar-un-repositorio","text":"Una vez que ya tengamos sincronizado el repositorio contra Github, eventualmente vamos a querer descargarlo en otro de nuestros ordenadores para poder trabajar en \u00e9l. Esta acci\u00f3n se denomina clonar y para ello usaremos la orden git clone . En la p\u00e1gina principal de nuestro proyecto podemos ver un bot\u00f3n que indica Clone or download . Si la pulsamos nos da, de nuevo, la opci\u00f3n de elegir entre clonar con ssh o https . Recordad que si est\u00e1is en otro equipo y quer\u00e9is seguir utilizando ssh deber\u00e9is generar otra para de claves privada/p\u00fablica como hicimos en la secci\u00f3n de Aspectos b\u00e1sicos de Git y instalarla en nuestro perfil de Github, como vimos anteriormente. Para clonar nuestro repositorio y poder trabajar con \u00e9l todo lo que debemos hacer es lo siguiente: $ git clone git@github.com:sgomez/taller-de-git.git $ cd taller-de-git","title":"Clonar un repositorio"},{"location":"github/#ramas-remotas","text":"Si ahora vemos el estado de nuestro proyecto veremos algo similar a esto: $ git hist --all * 2eab8ca 2013-06-16 | Aplicando los cambios de la rama hola (HEAD -> master, origin/master) [Sergio Gomez] *\\ | * 9862f33 2013-06-16 | hola usa la clase HolaMundo (hola) [Sergio G\u00f3mez] | * 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez] |/ * 9c85275 2013-06-16 | Programa interactivo (master) [Sergio G\u00f3mez] * c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez] * 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez] * 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez] * fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez] * 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez] * efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez] * e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez] Aparece que hay una nueva rama llamada origin/master . Esta rama indica el estado de sincronizaci\u00f3n de nuestro repositorio con un repositorio remoto llamado origin . En este caso el de Github . Info Por norma se llama autom\u00e1ticamente origin al primer repositorio con el que sincronizamos nuestro repositorio. Podemos ver la configuraci\u00f3n de este repositorio remoto con la orden git remote : $ git remote show origin * remote origin Fetch URL: git@github.com:sgomez/taller-de-git.git Push URL: git@github.com:sgomez/taller-de-git.git HEAD branch: master Remote branch: master tracked Local ref configured for 'git push': master pushes to master (up to date) De la respuesta tenemos que fijarnos en las l\u00edneas que indican fetch y push puesto que son las acciones de sincronizaci\u00f3n de nuestro repositorio con el remoto. Mientras que fetch se encarga de traer los cambios desde el repositorio remoto al nuestro, push los env\u00eda.","title":"Ramas remotas"},{"location":"github/#enviando-actualizaciones","text":"Vamos a a\u00f1adir una licencia a nuestra aplicaci\u00f3n. Creamos un fichero LICENSE con el siguiente contenido: MIT License Copyright (c) [year] [fullname] Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. Y a\u00f1adidos y confirmamos los cambios: $ git add LICENSE $ git commit -m \"A\u00f1adida licencia\" [master 3f5cb1c] A\u00f1adida licencia 1 file changed, 21 insertions(+) create mode 100644 LICENSE $ git hist --all * 3f5cb1c 2013-06-16 | A\u00f1adida licencia (HEAD -> master) [Sergio G\u00f3mez] * 2eab8ca 2013-06-16 | Aplicando los cambios de la rama hola (origin/master) [Sergio Gomez] *\\ | * 9862f33 2013-06-16 | hola usa la clase HolaMundo (hola) [Sergio G\u00f3mez] | * 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez] |/ * 9c85275 2013-06-16 | Programa interactivo (master) [Sergio G\u00f3mez] * c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez] * 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez] * 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez] * fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez] * 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez] * efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez] * e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez] Viendo la historia podemos ver como nuestro master no est\u00e1 en el mismo punto que origin/master . Si vamos a la web de Github veremos que LICENSE no aparece a\u00fan. As\u00ed que vamos a enviar los cambios con la primera de las acciones que vimos git push : $ git push -u origin master Counting objects: 3, done. Delta compression using up to 4 threads. Compressing objects: 100% (3/3), done. Writing objects: 100% (3/3), 941 bytes | 0 bytes/s, done. Total 3 (delta 0), reused 0 (delta 0) To git@github.com:sgomez/taller-de-git.git 2eab8ca..3f5cb1c master -> master Branch master set up to track remote branch master from origin. Info La orden git push necesita dos par\u00e1metros para funcionar: el repositorio y la rama destino. As\u00ed que realmente lo que ten\u00edamos que haber escrito es: $ git push origin master Para ahorrar tiempo escribiendo git nos deja vincular nuestra rama local con una rama remota, de tal manera que no tengamos que estar siempre indic\u00e1ndolo. Eso es posible con el par\u00e1metro --set-upstream o -u en forma abreviada. $ git push -u origin master Si repasas las \u00f3rdenes que te indic\u00f3 Github que ejecutaras ver\u00e1s que el par\u00e1metro -u estaba presente y por eso no ha sido necesario indicar ning\u00fan par\u00e1metro al hacer push.","title":"Enviando actualizaciones"},{"location":"github/#recibiendo-actualizaciones","text":"Si trabajamos con m\u00e1s personas, o trabajamos desde dos ordenadores distintos, nos encontraremos con que nuestro repositorio local es m\u00e1s antiguo que el remoto. Necesitamos descargar los cambios para poder incorporarlos a nuestro directorio de trabajo. Para la prueba, Github nos permite editar archivos directamente desde la web. Pulsamos sobre el archivo README.md . En la vista del archivo, veremos que aparece el icono de un l\u00e1piz. Esto nos permite editar el archivo. Info Los archivos con extensi\u00f3n .md est\u00e1n en un formato denominado MarkDown . Se trata de un lenguaje de marca que nos permite escribir texto enriquecido de manera muy sencilla. Dispones de un tutorial aqu\u00ed: https://www.markdowntutorial.com/ Modificamos el archivo como queramos, por ejemplo, a\u00f1adiendo nuestro nombre: # Curso de GIT Este proyecto contiene el curso de introducci\u00f3n a GIT Desarrollado por Sergio G\u00f3mez. El cambio quedar\u00e1 incorporado al repositorio de Github, pero no al nuestro. Necesitamos traer la informaci\u00f3n desde el servidor remoto. La orden asociada es git fetch : $ git fetch $ git hist --all * cbaf831 2013-06-16 | Actualizado README.md (origin/master) [Sergio G\u00f3mez] * 3f5cb1c 2013-06-16 | A\u00f1adida licencia (HEAD -> master) [Sergio G\u00f3mez] * 2eab8ca 2013-06-16 | Aplicando los cambios de la rama hola [Sergio Gomez] *\\ | * 9862f33 2013-06-16 | hola usa la clase HolaMundo (hola) [Sergio G\u00f3mez] | * 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez] |/ * 9c85275 2013-06-16 | Programa interactivo (master) [Sergio G\u00f3mez] * c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez] * 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez] * 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez] * fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez] * 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez] * efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez] * e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez] Ahora vemos el caso contrario, tenemos que origin/master est\u00e1 por delante que HEAD y que la rama master local. Ahora necesitamos incorporar los cambios de la rama remota en la local. La forma de hacerlo lo vimos en el cap\u00edtulo anterior usando git merge o git rebase . Habitualmente se usa git merge : $ git merge origin/master Updating 3f5cb1c..cbaf831 Fast-forward README.md | 2 ++ 1 file changed, 2 insertions(+) $ git hist --all * cbaf831 2013-06-16 | Actualizado README.md (HEAD -> master, origin/master) [Sergio G\u00f3mez] * 3f5cb1c 2013-06-16 | A\u00f1adida licencia [Sergio G\u00f3mez] * 2eab8ca 2013-06-16 | Aplicando los cambios de la rama hola [Sergio Gomez] *\\ | * 9862f33 2013-06-16 | hola usa la clase HolaMundo (hola) [Sergio G\u00f3mez] | * 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez] |/ * 9c85275 2013-06-16 | Programa interactivo (master) [Sergio G\u00f3mez] * c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez] * 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez] * 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez] * fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez] * 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez] * efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez] * e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez] Como las operaciones de traer cambios ( git fetch ) y de mezclar ramas ( git merge o git rebase ) est\u00e1n muy asociadas, git nos ofrece una posibilidad para ahorrar pasos que es la orden git pull que realiza las dos acciones simult\u00e1neamente. Para probar, vamos a editar de nuevo el archivo README.md y a\u00f1adimos algo m\u00e1s: # Curso de GIT Este proyecto contiene el curso de introducci\u00f3n a GIT del Aula de Software Libre. Desarrollado por Sergio G\u00f3mez. Como mensaje del commit : 'Indicado que se realiza en el ASL' . Y ahora probamos a actualizar con git pull : $ git pull remote: Counting objects: 3, done. remote: Compressing objects: 100% (3/3), done. remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 Unpacking objects: 100% (3/3), done. From github.com:sgomez/taller-de-git cbaf831..d8922e4 master -> origin/master First, rewinding head to replay your work on top of it... Fast-forwarded master to d8922e4ffa4f87553b03e77df6196b7e496bfec4. $ git hist --all * d8922e4 2013-06-16 | Indicado que se realiza en el ASL (HEAD -> master, origin/master) [Sergio G\u00f3mez] * cbaf831 2013-06-16 | Actualizado README.md [Sergio G\u00f3mez] * 3f5cb1c 2013-06-16 | A\u00f1adida licencia [Sergio G\u00f3mez] * 2eab8ca 2013-06-16 | Aplicando los cambios de la rama hola [Sergio Gomez] *\\ | * 9862f33 2013-06-16 | hola usa la clase HolaMundo (hola) [Sergio G\u00f3mez] | * 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez] |/ * 9c85275 2013-06-16 | Programa interactivo (master) [Sergio G\u00f3mez] * c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez] * 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez] * 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez] * fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez] * 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez] * efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez] * e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez] Vemos que los cambios se han incorporado y que las ramas remota y local de master est\u00e1n sincronizadas.","title":"Recibiendo actualizaciones"},{"location":"github/#problemas-de-sincronizacion","text":"","title":"Problemas de sincronizaci\u00f3n"},{"location":"github/#no-puedo-hacer-push","text":"Al intentar subir cambios nos podemos encontrar un mensaje como este: $ git push git push To git@github.com:sgomez/taller-de-git.git ! [rejected] master -> master (fetch first) error: failed to push some refs to 'git@github.com:sgomez/taller-de-git.git' hint: Updates were rejected because the remote contains work that you do hint: not have locally. This is usually caused by another repository pushing hint: to the same ref. You may want to first integrate the remote changes hint: (e.g., 'git pull ...') before pushing again. hint: See the 'Note about fast-forwards' in 'git push --help' for details. La causa es que el repositorio remoto tambi\u00e9n se ha actualizado y nosotros a\u00fan no hemos recibido esos cambios. Es decir, ambos repositorios se han actualizado y el remoto tiene preferencia. Hay un conflicto en ciernes y se debe resolver localmente antes de continuar. Vamos a provocar una situaci\u00f3n donde podamos ver esto en acci\u00f3n. Vamos a modificar el archivo README.md tanto en local como en remoto a trav\u00e9s del interfaz web. En el web vamos a cambiar el t\u00edtulo para que aparezca de la siguiente manera. Curso de GIT, 2020 En local vamos a cambiar el t\u00edtulo para que aparezca de la siguiente manera. Curso de GIT, febrero Question Haz el commit para guardar el cambio en local. ??? example \"Respuesta al ejercicio anterior\" A\u00f1adimos el fichero actualizado: $ git commit -am \"A\u00f1adido el mes al README\" [master 1e8c0b7] A\u00f1adido el mes al README 1 file changed, 1 insertion(+), 1 deletion(-) La forma de proceder en este caso es hacer un git fetch y un git rebase . Si hay conflictos deber\u00e1n resolverse. Cuando est\u00e9 todo solucionado ya podremos hacer git push . Info Por defecto git pull lo que hace es un git merge , si queremos hacer git rebase deberemos especificarlos con el par\u00e1metro -r : $ git pull --rebase Vamos a hacer el pull con rebase y ver qu\u00e9 sucede. $ git pull --rebase First, rewinding head to replay your work on top of it... Applying: A\u00f1adido el mes al README Using index info to reconstruct a base tree... M README.md Falling back to patching base and 3-way merge... Auto-merging README.md CONFLICT (content): Merge conflict in README.md error: Failed to merge in the changes. Patch failed at 0001 A\u00f1adido el mes al README hint: Use 'git am --show-current-patch' to see the failed patch Resolve all conflicts manually, mark them as resolved with \"git add/rm <conflicted_files>\", then run \"git rebase --continue\". You can instead skip this commit: run \"git rebase --skip\". To abort and get back to the state before \"git rebase\", run \"git rebase --abort\". Evidentemente hay un conflicto porque hemos tocado el mismo archivo. Se deja como ejercicio resolverlo. ??? example \"Respuesta al ejercicio anterior\" El contenido del fichero final podr\u00eda ser: Curso de GIT, febrero, 2020 A continuaci\u00f3n confirmamos los cambios y los enviamos al servidor $ git add README.md $ git rebase --continue $ git push Warning \u00bfPor qu\u00e9 hemos hecho rebase en master si a lo largo del curso hemos dicho que no se debe cambiar la linea principal? B\u00e1sicamente hemos dicho que lo que no debemos hacer es modificar la l\u00ednea temporal compartida . En este caso nuestros cambios en master solo estaban en nuestro repositorio, porque al fallar el env\u00edo nadie m\u00e1s ha visto nuestras actualizaciones. Al hacer rebase estamos deshaciendo nuestros cambios, bajarnos la \u00faltima actualizaci\u00f3n compartida de master y volvi\u00e9ndolos a aplicar. Con lo que realmente la historia compartida no se ha modificado. Este es un problema que debemos evitar en la medida de lo posible. La menor cantidad de gente posible debe tener acceso de escritura en master y las actualizaciones de dicha rama deben hacerse a trav\u00e9s de ramas secundarias y haciendo merge en master como hemos visto en el cap\u00edtulo de ramas.","title":"No puedo hacer push"},{"location":"github/#no-puedo-hacer-pull","text":"Al intentar descargar cambios nos podemos encontrar un mensaje como este: $ git pull error: Cannot pull with rebase: You have unstaged changes. O como este: $ git pull error: Cannot pull with rebase: Your index contains uncommitted changes. B\u00e1sicamente lo que ocurre es que tenemos cambios sin confirmar en nuestro espacio de trabajo. Una opci\u00f3n es confirmar ( commit ) y entonces proceder como el caso anterior. Pero puede ocurrir que a\u00fan estemos trabajando todav\u00eda y no nos interese confirmar los cambios, solo queremos sincronizar y seguir trabajando. Para casos como estos git ofrece una pila para guardar cambios temporalmente. Esta pila se llama stash y nos permite restaurar el espacio de trabajo al \u00faltimo commit. De nuevo vamos a modificar nuestro proyecto para ver esta situaci\u00f3n en acci\u00f3n. Example En remoto borra el a\u00f1o de la fecha y en local borra el mes. Pero esta vez no hagas commit en local . El archivo solo debe quedar modificado. La forma de proceder es la siguiente: $ git stash save # Guardamos los cambios en la pila $ git pull # Sincronizamos con el repositorio remoto, -r para hacer rebase puede ser requerido $ git stash pop # Sacamos los cambios de la pila Info Como ocurre habitualmente, git nos proporciona una forma de hacer todos estos pasos de una sola vez. Para ello tenemos que ejecutar lo siguiente: $ git pull --autostash En general no es mala idea ejecutar lo siguiente si somos conscientes, adem\u00e1s, de que tenemos varios cambios sin sincronizar: $ git pull --autostash --rebase Podr\u00eda darse el caso de que al sacar los cambios de la pila hubiera alg\u00fan conflicto. En ese caso actuamos como con el caso de merge o rebase . De nuevo este tipo de problemas no deben suceder si nos acostumbramos a trabajar en ramas.","title":"No puedo hacer pull"},{"location":"introduccion/","text":"Introducci\u00f3n a git \u00b6 Git es un sistema de control de versiones distribuido que se diferencia del resto en el modo en que modela sus datos. La mayor\u00eda de los dem\u00e1s sistemas almacenan la informaci\u00f3n como una lista de cambios en los archivos, mientras que Git modela sus datos m\u00e1s como un conjunto de instant\u00e1neas de un mini sistema de archivos. Los tres estados \u00b6 Git tiene tres estados principales en los que se pueden encontrar tus archivos: confirmado (committed), modificado (modified), y preparado (staged). Confirmado significa que los datos est\u00e1n almacenados de manera segura en tu base de datos local. Modificado significa que has modificado el archivo pero todav\u00eda no lo has confirmado a tu base de datos. Preparado significa que has marcado un archivo modificado en su versi\u00f3n actual para que vaya en tu pr\u00f3xima confirmaci\u00f3n. Esto nos lleva a las tres secciones principales de un proyecto de Git: el directorio de Git (Git directory), el directorio de trabajo (working directory), y el \u00e1rea de preparaci\u00f3n (staging area). Flujos de trabajo distribuidos con git \u00b6 Hemos visto en qu\u00e9 consiste un entorno de control de versiones distribuido, pero m\u00e1s all\u00e1 de la simple definici\u00f3n, existe m\u00e1s de una manera de gestionar los repositorios. Estos son los flujos de trabajo m\u00e1s comunes en Git. Flujo de trabajo centralizado \u00b6 Existe un \u00fanico repositorio o punto central que guarda el c\u00f3digo y todo el mundo sincroniza su trabajo con \u00e9l. Si dos desarrolladores clonan desde el punto central, y ambos hacen cambios; tan solo el primero de ellos en enviar sus cambios de vuelta lo podr\u00e1 hacer limpiamente. El segundo desarrollador deber\u00e1 fusionar previamente su trabajo con el del primero, antes de enviarlo, para evitar el sobreescribir los cambios del primero Flujo de trabajo del Gestor-de-Integraciones \u00b6 Al permitir m\u00faltiples repositorios remotos, en Git es posible tener un flujo de trabajo donde cada desarrollador tenga acceso de escritura a su propio repositorio p\u00fablico y acceso de lectura a los repositorios de todos los dem\u00e1s. Habitualmente, este escenario suele incluir un repositorio can\u00f3nico, representante \"oficial\" del proyecto. Info Este modelo se puso muy de moda a ra\u00edz de la forja GitHub que se ver\u00e1 m\u00e1s adelante. Flujo de trabajo con Dictador y Tenientes \u00b6 Es una variante del flujo de trabajo con m\u00faltiples repositorios. Se utiliza generalmente en proyectos muy grandes, con cientos de colaboradores. Un ejemplo muy conocido es el del kernel de Linux. Unos gestores de integraci\u00f3n se encargan de partes concretas del repositorio; y se denominan tenientes. Todos los tenientes rinden cuentas a un gestor de integraci\u00f3n; conocido como el dictador benevolente. El repositorio del dictador benevolente es el repositorio de referencia, del que recuperan (pull) todos los colaboradores.","title":"Introducci\u00f3n a git"},{"location":"introduccion/#introduccion-a-git","text":"Git es un sistema de control de versiones distribuido que se diferencia del resto en el modo en que modela sus datos. La mayor\u00eda de los dem\u00e1s sistemas almacenan la informaci\u00f3n como una lista de cambios en los archivos, mientras que Git modela sus datos m\u00e1s como un conjunto de instant\u00e1neas de un mini sistema de archivos.","title":"Introducci\u00f3n a git"},{"location":"introduccion/#los-tres-estados","text":"Git tiene tres estados principales en los que se pueden encontrar tus archivos: confirmado (committed), modificado (modified), y preparado (staged). Confirmado significa que los datos est\u00e1n almacenados de manera segura en tu base de datos local. Modificado significa que has modificado el archivo pero todav\u00eda no lo has confirmado a tu base de datos. Preparado significa que has marcado un archivo modificado en su versi\u00f3n actual para que vaya en tu pr\u00f3xima confirmaci\u00f3n. Esto nos lleva a las tres secciones principales de un proyecto de Git: el directorio de Git (Git directory), el directorio de trabajo (working directory), y el \u00e1rea de preparaci\u00f3n (staging area).","title":"Los tres estados"},{"location":"introduccion/#flujos-de-trabajo-distribuidos-con-git","text":"Hemos visto en qu\u00e9 consiste un entorno de control de versiones distribuido, pero m\u00e1s all\u00e1 de la simple definici\u00f3n, existe m\u00e1s de una manera de gestionar los repositorios. Estos son los flujos de trabajo m\u00e1s comunes en Git.","title":"Flujos de trabajo distribuidos con git"},{"location":"introduccion/#flujo-de-trabajo-centralizado","text":"Existe un \u00fanico repositorio o punto central que guarda el c\u00f3digo y todo el mundo sincroniza su trabajo con \u00e9l. Si dos desarrolladores clonan desde el punto central, y ambos hacen cambios; tan solo el primero de ellos en enviar sus cambios de vuelta lo podr\u00e1 hacer limpiamente. El segundo desarrollador deber\u00e1 fusionar previamente su trabajo con el del primero, antes de enviarlo, para evitar el sobreescribir los cambios del primero","title":"Flujo de trabajo centralizado"},{"location":"introduccion/#flujo-de-trabajo-del-gestor-de-integraciones","text":"Al permitir m\u00faltiples repositorios remotos, en Git es posible tener un flujo de trabajo donde cada desarrollador tenga acceso de escritura a su propio repositorio p\u00fablico y acceso de lectura a los repositorios de todos los dem\u00e1s. Habitualmente, este escenario suele incluir un repositorio can\u00f3nico, representante \"oficial\" del proyecto. Info Este modelo se puso muy de moda a ra\u00edz de la forja GitHub que se ver\u00e1 m\u00e1s adelante.","title":"Flujo de trabajo del Gestor-de-Integraciones"},{"location":"introduccion/#flujo-de-trabajo-con-dictador-y-tenientes","text":"Es una variante del flujo de trabajo con m\u00faltiples repositorios. Se utiliza generalmente en proyectos muy grandes, con cientos de colaboradores. Un ejemplo muy conocido es el del kernel de Linux. Unos gestores de integraci\u00f3n se encargan de partes concretas del repositorio; y se denominan tenientes. Todos los tenientes rinden cuentas a un gestor de integraci\u00f3n; conocido como el dictador benevolente. El repositorio del dictador benevolente es el repositorio de referencia, del que recuperan (pull) todos los colaboradores.","title":"Flujo de trabajo con Dictador y Tenientes"},{"location":"ramas/","text":"Ramas \u00b6 Administraci\u00f3n de ramas \u00b6 Crear una nueva rama \u00b6 Cuando vamos a trabajar en una nueva funcionalidad, es conveniente hacerlo en una nueva rama, para no modificar la rama principal y dejarla inestable. Aunque la orden para manejar ramas es git branch podemos usar tambi\u00e9n git checkout . Vamos a crear una nueva rama: git branch hola Info Si usamos git branch sin ning\u00fan argumento, nos devolver\u00e1 la lista de ramas disponibles. La orden anterior no devuelve ning\u00fan resultado y tampoco nos cambia de rama, para eso debemos usar checkout : $ git checkout hola Switched to branch 'hola' Tip Hay una forma m\u00e1s rapida de hacer ambas acciones en un solo paso. Con el par\u00e1metro -b de git checkout podemos cambiarnos a una rama que, si no existe, se crea instant\u00e1neamente. $ git checkout -b hola Switched to a new branch 'hola' Modificaciones en la rama secundaria \u00b6 A\u00f1adimos un nuevo archivo en el directorio lib llamado HolaMundo.php : <?php class HolaMundo { private $nombre ; function __construct ( $nombre ) { $this -> nombre = $nombre ; } function __toString () { return sprintf ( \"Hola, %s. \\n \" , $this -> nombre ); } } Y modificamos hola.php : <?php // Autor: Sergio G\u00f3mez <sergio@uco.es> // El nombre por defecto es Mundo require ( 'HolaMundo.php' ); $nombre = isset ( $argv [ 1 ]) ? $argv [ 1 ] : \"Mundo\" ; print new HolaMundo ( $nombre ); Podr\u00edamos confirmar los cambios todos de golpe, pero lo haremos de uno en uno, con su comentario. $ git add lib/HolaMundo.php $ git commit -m \"A\u00f1adida la clase HolaMundo\" [hola 6932156] A\u00f1adida la clase HolaMundo 1 file changed, 16 insertions(+) create mode 100644 lib/HolaMundo.php $ git add lib/hola.php $ git commit -m \"hola usa la clase HolaMundo\" [hola 9862f33] hola usa la clase HolaMundo 1 file changed, 3 insertions(+), 1 deletion(-) Y ahora con la orden git checkout podemos movernos entre ramas: $ git checkout master Switched to branch 'master' $ git checkout hola Switched to branch 'hola' Modificaciones en la rama master \u00b6 Podemos volver y a\u00f1adir un nuevo archivo a la rama principal: $ git checkout master Switched to branch 'master' Creamos un archivo llamado README.md en la ra\u00edz de nuestro proyecto con el siguiente contenido: # Curso de GIT Este proyecto contiene el curso de introducci\u00f3n a GIT Y lo a\u00f1adimos a nuestro repositorio en la rama en la que estamos: $ git add README.md $ git commit -m \"A\u00f1adido README.md\" [master c3e65d0] A\u00f1adido README.md 1 file changed, 3 insertions(+) create mode 100644 README.md $ git hist --all * c3e65d0 2013-06-16 | A\u00f1adido README.md (HEAD, master) [Sergio G\u00f3mez] | * 9862f33 2013-06-16 | hola usa la clase HolaMundo (hola) [Sergio G\u00f3mez] | * 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez] |/ * 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez] * 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez] * fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez] * 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez] * efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez] * e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez] Y vemos como git hist muestra la bifurcaci\u00f3n en nuestro c\u00f3digo. Fusi\u00f3n de ramas y resoluci\u00f3n de conflictos \u00b6 Mezclar ramas \u00b6 Podemos incorporar los cambios de una rama a otra con la orden git merge $ git checkout hola Switched to branch 'hola' $ git merge master Merge made by the 'recursive' strategy. README.md | 3 +++ 1 file changed, 3 insertions(+) create mode 100644 README.md $ git hist --all * 9c6ac06 2013-06-16 | Merge commit 'c3e65d0' into hola (HEAD, hola) [Sergio G\u00f3mez] |\\ * | 9862f33 2013-06-16 | hola usa la clase HolaMundo [Sergio G\u00f3mez] * | 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez] | | | * c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez] |/ * 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez] * 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez] * fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez] * 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez] * efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez] * e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez] De esa forma se puede trabajar en una rama secundaria incorporando los cambios de la rama principal o de otra rama. Resolver conflictos \u00b6 Un conflicto es cuando se produce una fusi\u00f3n que Git no es capaz de resolver. Vamos a modificar la rama master para crear uno con la rama hola. $ git checkout master Switched to branch 'master' Modificamos nuestro archivo hola.php de nuevo: <?php // Autor: Sergio G\u00f3mez <sergio@uco.es> print \"Introduce tu nombre:\" ; $nombre = trim ( fgets ( STDIN )); @ print \"Hola, { $nombre } \\n \" ; Y guardamos los cambios: $ git add lib/hola.php $ git commit -m \"Programa interactivo\" [master 9c85275] Programa interactivo 1 file changed, 2 insertions(+), 2 deletions(-) $ git hist --all * 9c6ac06 2013-06-16 | Merge commit 'c3e65d0' into hola (hola) [Sergio G\u00f3mez] |\\ * | 9862f33 2013-06-16 | hola usa la clase HolaMundo [Sergio G\u00f3mez] * | 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez] | | * 9c85275 2013-06-16 | Programa interactivo (HEAD, master) [Sergio G\u00f3mez] | |/ | * c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez] |/ * 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez] * 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez] * fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez] * 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez] * efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez] * e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez] Volvemos a la rama hola y fusionamos: $ git checkout hola Switched to branch 'hola' $ git merge master Auto-merging lib/hola.php CONFLICT (content): Merge conflict in lib/hola.php Automatic merge failed; fix conflicts and then commit the result. Si editamos nuestro archivo lib/hola.php obtendremos algo similar a esto: <?php // Autor: Sergio G\u00f3mez <sergio@uco.es> <<<<<<< HEAD // El nombre por defecto es Mundo require ( 'HolaMundo.php' ); $nombre = isset ( $argv [ 1 ]) ? $argv [ 1 ] : \"Mundo\" ; print new HolaMundo ( $nombre ); ======= print \"Introduce tu nombre:\" ; $nombre = trim ( fgets ( STDIN )); @ print \"Hola, { $nombre } \\n \" ; >>>>>>> master La primera parte marca el c\u00f3digo que estaba en la rama donde trabaj\u00e1bamos (HEAD) y la parte final el c\u00f3digo de donde fusion\u00e1bamos. Resolvemos el conflicto, dejando el archivo como sigue: <?php // Autor: Sergio G\u00f3mez <sergio@uco.es> require ( 'HolaMundo.php' ); print \"Introduce tu nombre:\" ; $nombre = trim ( fgets ( STDIN )); print new HolaMundo ( $nombre ); Y resolvemos el conflicto confirmando los cambios: $ git add lib/hola.php $ git commit -m \"Solucionado el conflicto al fusionar con la rama master\" [hola a36af04] Solucionado el conflicto al fusionar con la rama master Rebasing vs Merging \u00b6 Rebasing es otra t\u00e9cnica para fusionar distinta a merge y usa la orden git rebase . Vamos a dejar nuestro proyecto como estaba antes del fusionado. Para ello necesitamos anotar el hash anterior al de la acci\u00f3n de merge . El que tiene la anotaci\u00f3n \"hola usa la clase HolaMundo\" . Para ello podemos usar la orden git reset que nos permite mover HEAD donde queramos. $ git checkout hola Switched to branch 'hola' $ git hist * a36af04 2013-06-16 | Solucionado el conflicto al fusionar con la rama master (HEAD, hola) [Sergio G\u00f3mez] |\\ | * 9c85275 2013-06-16 | Programa interactivo (master) [Sergio G\u00f3mez] * | 9c6ac06 2013-06-16 | Merge commit 'c3e65d0' into hola [Sergio G\u00f3mez] |\\ \\ | |/ | * c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez] * | 9862f33 2013-06-16 | hola usa la clase HolaMundo [Sergio G\u00f3mez] * | 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez] |/ * 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez] * 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez] * fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez] * 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez] * efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez] * e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez] $ git reset --hard 9862f33 HEAD is now at 9862f33 hola usa la clase HolaMundo Y nuestro estado ser\u00e1: $ git hist --all * 9862f33 2013-06-16 | hola usa la clase HolaMundo (HEAD, hola) [Sergio G\u00f3mez] * 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez] | * 9c85275 2013-06-16 | Programa interactivo (master) [Sergio G\u00f3mez] | * c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez] |/ * 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez] * 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez] * fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez] * 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez] * efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez] * e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez] Hemos desecho todos los merge y nuestro \u00e1rbol est\u00e1 \"limpio\" . Vamos a probar ahora a hacer un rebase. Continuamos en la rama hola y ejecutamos lo siguiente: $ git rebase master First, rewinding head to replay your work on top of it... Applying: A\u00f1adida la clase HolaMundo Applying: hola usa la clase HolaMundo Using index info to reconstruct a base tree... M lib/hola.php Falling back to patching base and 3-way merge... Auto-merging lib/hola.php CONFLICT (content): Merge conflict in lib/hola.php error: Failed to merge in the changes. Patch failed at 0002 hola usa la clase HolaMundo The copy of the patch that failed is found in: .git/rebase-apply/patch When you have resolved this problem, run \"git rebase --continue\". If you prefer to skip this patch, run \"git rebase --skip\" instead. To check out the original branch and stop rebasing, run \"git rebase --abort\". El conflicto, por supuesto, se sigue dando. Resolvemos guardando el archivo hola.php como en los casos anteriores: <?php // Autor: Sergio G\u00f3mez <sergio@uco.es> require ( 'HolaMundo.php' ); print \"Introduce tu nombre:\" ; $nombre = trim ( fgets ( STDIN )); print new HolaMundo ( $nombre ); A\u00f1adimos los cambios en staging y en esta ocasi\u00f3n, y tal como nos indicaba en el mensaje anterior, no tenemos que hacer git commit sino continuar con el rebase : $ git add lib/hola.php $ git status rebase in progress; onto 269eaca You are currently rebasing branch 'hola' on '269eaca'. (all conflicts fixed: run \"git rebase --continue\") Changes to be committed: (use \"git reset HEAD <file>...\" to unstage) modified: lib/hola.php $ git rebase --continue Applying: hola usa la clase HolaMundo Y ahora vemos que nuestro \u00e1rbol tiene un aspecto distinto, mucho m\u00e1s limpio: $ git hist --all * 9862f33 2013-06-16 | hola usa la clase HolaMundo (HEAD -> hola) [Sergio G\u00f3mez] * 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez] * 9c85275 2013-06-16 | Programa interactivo (master) [Sergio G\u00f3mez] * c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez] * 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez] * 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez] * fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez] * 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez] * efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez] * e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez] Lo que hace rebase es volver a aplicar todos los cambios a la rama m\u00e1ster, desde su nodo m\u00e1s reciente. Eso significa que se modifica el orden o la historia de creaci\u00f3n de los cambios. Por eso rebase no debe usarse si el orden es importante o si la rama es compartida. Mezclando con la rama master \u00b6 Ya hemos terminado de implementar los cambios en nuestra rama secundaria y es hora de llevar los cambios a la rama principal. Usamos git merge para hacer una fusi\u00f3n normal: $ git checkout master Switched to branch 'master' $ git merge hola Updating c3e65d0..491f1d2 Fast-forward lib/HolaMundo.php | 16 ++++++++++++++++ lib/hola.php | 4 +++- 2 files changed, 19 insertions(+), 1 deletion(-) create mode 100644 lib/HolaMundo.php $ git hist --all * 9862f33 2013-06-16 | hola usa la clase HolaMundo (HEAD -> master, hola) [Sergio G\u00f3mez] * 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez] * 9c85275 2013-06-16 | Programa interactivo [Sergio G\u00f3mez] * c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez] * 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez] * 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez] * fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez] * 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez] * efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez] * e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez] Vemos que indica que el tipo de fusi\u00f3n es fast-forward . Este tipo de fusi\u00f3n tiene el problema que no deja rastro de la fusi\u00f3n, por eso suele ser recomendable usar el par\u00e1metro --no-ff para que quede constancia siempre de que se ha fusionado una rama con otra. Vamos a volver a probar ahora sin hacer fast-forward . Reseteamos master al estado \"Programa interactivo\" . $ git reset --hard 9c85275 $ git hist --all * 9862f33 2013-06-16 | hola usa la clase HolaMundo (HEAD -> hola) [Sergio G\u00f3mez] * 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez] * 9c85275 2013-06-16 | Programa interactivo (master) [Sergio G\u00f3mez] * c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez] * 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez] * 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez] * fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez] * 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez] * efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez] * e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez] Vemos que estamos como en el final de la secci\u00f3n anterior, as\u00ed que ahora mezclamos: $ git merge -m \"Aplicando los cambios de la rama hola\" --no-ff hola Merge made by the 'recursive' strategy. lib/HolaMundo.php | 16 ++++++++++++++++ lib/hola.php | 4 +++- 2 files changed, 19 insertions(+), 1 deletion(-) create mode 100644 lib/HolaMundo.php $ git hist --all * 2eab8ca 2013-06-16 | Aplicando los cambios de la rama hola (HEAD -> master) [Sergio Gomez] *\\ | * 9862f33 2013-06-16 | hola usa la clase HolaMundo (hola) [Sergio G\u00f3mez] | * 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez] |/ * 9c85275 2013-06-16 | Programa interactivo (master) [Sergio G\u00f3mez] * c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez] * 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez] * 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez] * fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez] * 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez] * efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez] * e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez] En la siguiente imagen se puede ver la diferencia:","title":"Ramas"},{"location":"ramas/#ramas","text":"","title":"Ramas"},{"location":"ramas/#administracion-de-ramas","text":"","title":"Administraci\u00f3n de ramas"},{"location":"ramas/#crear-una-nueva-rama","text":"Cuando vamos a trabajar en una nueva funcionalidad, es conveniente hacerlo en una nueva rama, para no modificar la rama principal y dejarla inestable. Aunque la orden para manejar ramas es git branch podemos usar tambi\u00e9n git checkout . Vamos a crear una nueva rama: git branch hola Info Si usamos git branch sin ning\u00fan argumento, nos devolver\u00e1 la lista de ramas disponibles. La orden anterior no devuelve ning\u00fan resultado y tampoco nos cambia de rama, para eso debemos usar checkout : $ git checkout hola Switched to branch 'hola' Tip Hay una forma m\u00e1s rapida de hacer ambas acciones en un solo paso. Con el par\u00e1metro -b de git checkout podemos cambiarnos a una rama que, si no existe, se crea instant\u00e1neamente. $ git checkout -b hola Switched to a new branch 'hola'","title":"Crear una nueva rama"},{"location":"ramas/#modificaciones-en-la-rama-secundaria","text":"A\u00f1adimos un nuevo archivo en el directorio lib llamado HolaMundo.php : <?php class HolaMundo { private $nombre ; function __construct ( $nombre ) { $this -> nombre = $nombre ; } function __toString () { return sprintf ( \"Hola, %s. \\n \" , $this -> nombre ); } } Y modificamos hola.php : <?php // Autor: Sergio G\u00f3mez <sergio@uco.es> // El nombre por defecto es Mundo require ( 'HolaMundo.php' ); $nombre = isset ( $argv [ 1 ]) ? $argv [ 1 ] : \"Mundo\" ; print new HolaMundo ( $nombre ); Podr\u00edamos confirmar los cambios todos de golpe, pero lo haremos de uno en uno, con su comentario. $ git add lib/HolaMundo.php $ git commit -m \"A\u00f1adida la clase HolaMundo\" [hola 6932156] A\u00f1adida la clase HolaMundo 1 file changed, 16 insertions(+) create mode 100644 lib/HolaMundo.php $ git add lib/hola.php $ git commit -m \"hola usa la clase HolaMundo\" [hola 9862f33] hola usa la clase HolaMundo 1 file changed, 3 insertions(+), 1 deletion(-) Y ahora con la orden git checkout podemos movernos entre ramas: $ git checkout master Switched to branch 'master' $ git checkout hola Switched to branch 'hola'","title":"Modificaciones en la rama secundaria"},{"location":"ramas/#modificaciones-en-la-rama-master","text":"Podemos volver y a\u00f1adir un nuevo archivo a la rama principal: $ git checkout master Switched to branch 'master' Creamos un archivo llamado README.md en la ra\u00edz de nuestro proyecto con el siguiente contenido: # Curso de GIT Este proyecto contiene el curso de introducci\u00f3n a GIT Y lo a\u00f1adimos a nuestro repositorio en la rama en la que estamos: $ git add README.md $ git commit -m \"A\u00f1adido README.md\" [master c3e65d0] A\u00f1adido README.md 1 file changed, 3 insertions(+) create mode 100644 README.md $ git hist --all * c3e65d0 2013-06-16 | A\u00f1adido README.md (HEAD, master) [Sergio G\u00f3mez] | * 9862f33 2013-06-16 | hola usa la clase HolaMundo (hola) [Sergio G\u00f3mez] | * 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez] |/ * 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez] * 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez] * fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez] * 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez] * efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez] * e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez] Y vemos como git hist muestra la bifurcaci\u00f3n en nuestro c\u00f3digo.","title":"Modificaciones en la rama master"},{"location":"ramas/#fusion-de-ramas-y-resolucion-de-conflictos","text":"","title":"Fusi\u00f3n de ramas y resoluci\u00f3n de conflictos"},{"location":"ramas/#mezclar-ramas","text":"Podemos incorporar los cambios de una rama a otra con la orden git merge $ git checkout hola Switched to branch 'hola' $ git merge master Merge made by the 'recursive' strategy. README.md | 3 +++ 1 file changed, 3 insertions(+) create mode 100644 README.md $ git hist --all * 9c6ac06 2013-06-16 | Merge commit 'c3e65d0' into hola (HEAD, hola) [Sergio G\u00f3mez] |\\ * | 9862f33 2013-06-16 | hola usa la clase HolaMundo [Sergio G\u00f3mez] * | 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez] | | | * c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez] |/ * 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez] * 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez] * fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez] * 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez] * efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez] * e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez] De esa forma se puede trabajar en una rama secundaria incorporando los cambios de la rama principal o de otra rama.","title":"Mezclar ramas"},{"location":"ramas/#resolver-conflictos","text":"Un conflicto es cuando se produce una fusi\u00f3n que Git no es capaz de resolver. Vamos a modificar la rama master para crear uno con la rama hola. $ git checkout master Switched to branch 'master' Modificamos nuestro archivo hola.php de nuevo: <?php // Autor: Sergio G\u00f3mez <sergio@uco.es> print \"Introduce tu nombre:\" ; $nombre = trim ( fgets ( STDIN )); @ print \"Hola, { $nombre } \\n \" ; Y guardamos los cambios: $ git add lib/hola.php $ git commit -m \"Programa interactivo\" [master 9c85275] Programa interactivo 1 file changed, 2 insertions(+), 2 deletions(-) $ git hist --all * 9c6ac06 2013-06-16 | Merge commit 'c3e65d0' into hola (hola) [Sergio G\u00f3mez] |\\ * | 9862f33 2013-06-16 | hola usa la clase HolaMundo [Sergio G\u00f3mez] * | 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez] | | * 9c85275 2013-06-16 | Programa interactivo (HEAD, master) [Sergio G\u00f3mez] | |/ | * c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez] |/ * 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez] * 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez] * fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez] * 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez] * efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez] * e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez] Volvemos a la rama hola y fusionamos: $ git checkout hola Switched to branch 'hola' $ git merge master Auto-merging lib/hola.php CONFLICT (content): Merge conflict in lib/hola.php Automatic merge failed; fix conflicts and then commit the result. Si editamos nuestro archivo lib/hola.php obtendremos algo similar a esto: <?php // Autor: Sergio G\u00f3mez <sergio@uco.es> <<<<<<< HEAD // El nombre por defecto es Mundo require ( 'HolaMundo.php' ); $nombre = isset ( $argv [ 1 ]) ? $argv [ 1 ] : \"Mundo\" ; print new HolaMundo ( $nombre ); ======= print \"Introduce tu nombre:\" ; $nombre = trim ( fgets ( STDIN )); @ print \"Hola, { $nombre } \\n \" ; >>>>>>> master La primera parte marca el c\u00f3digo que estaba en la rama donde trabaj\u00e1bamos (HEAD) y la parte final el c\u00f3digo de donde fusion\u00e1bamos. Resolvemos el conflicto, dejando el archivo como sigue: <?php // Autor: Sergio G\u00f3mez <sergio@uco.es> require ( 'HolaMundo.php' ); print \"Introduce tu nombre:\" ; $nombre = trim ( fgets ( STDIN )); print new HolaMundo ( $nombre ); Y resolvemos el conflicto confirmando los cambios: $ git add lib/hola.php $ git commit -m \"Solucionado el conflicto al fusionar con la rama master\" [hola a36af04] Solucionado el conflicto al fusionar con la rama master","title":"Resolver conflictos"},{"location":"ramas/#rebasing-vs-merging","text":"Rebasing es otra t\u00e9cnica para fusionar distinta a merge y usa la orden git rebase . Vamos a dejar nuestro proyecto como estaba antes del fusionado. Para ello necesitamos anotar el hash anterior al de la acci\u00f3n de merge . El que tiene la anotaci\u00f3n \"hola usa la clase HolaMundo\" . Para ello podemos usar la orden git reset que nos permite mover HEAD donde queramos. $ git checkout hola Switched to branch 'hola' $ git hist * a36af04 2013-06-16 | Solucionado el conflicto al fusionar con la rama master (HEAD, hola) [Sergio G\u00f3mez] |\\ | * 9c85275 2013-06-16 | Programa interactivo (master) [Sergio G\u00f3mez] * | 9c6ac06 2013-06-16 | Merge commit 'c3e65d0' into hola [Sergio G\u00f3mez] |\\ \\ | |/ | * c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez] * | 9862f33 2013-06-16 | hola usa la clase HolaMundo [Sergio G\u00f3mez] * | 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez] |/ * 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez] * 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez] * fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez] * 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez] * efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez] * e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez] $ git reset --hard 9862f33 HEAD is now at 9862f33 hola usa la clase HolaMundo Y nuestro estado ser\u00e1: $ git hist --all * 9862f33 2013-06-16 | hola usa la clase HolaMundo (HEAD, hola) [Sergio G\u00f3mez] * 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez] | * 9c85275 2013-06-16 | Programa interactivo (master) [Sergio G\u00f3mez] | * c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez] |/ * 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez] * 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez] * fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez] * 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez] * efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez] * e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez] Hemos desecho todos los merge y nuestro \u00e1rbol est\u00e1 \"limpio\" . Vamos a probar ahora a hacer un rebase. Continuamos en la rama hola y ejecutamos lo siguiente: $ git rebase master First, rewinding head to replay your work on top of it... Applying: A\u00f1adida la clase HolaMundo Applying: hola usa la clase HolaMundo Using index info to reconstruct a base tree... M lib/hola.php Falling back to patching base and 3-way merge... Auto-merging lib/hola.php CONFLICT (content): Merge conflict in lib/hola.php error: Failed to merge in the changes. Patch failed at 0002 hola usa la clase HolaMundo The copy of the patch that failed is found in: .git/rebase-apply/patch When you have resolved this problem, run \"git rebase --continue\". If you prefer to skip this patch, run \"git rebase --skip\" instead. To check out the original branch and stop rebasing, run \"git rebase --abort\". El conflicto, por supuesto, se sigue dando. Resolvemos guardando el archivo hola.php como en los casos anteriores: <?php // Autor: Sergio G\u00f3mez <sergio@uco.es> require ( 'HolaMundo.php' ); print \"Introduce tu nombre:\" ; $nombre = trim ( fgets ( STDIN )); print new HolaMundo ( $nombre ); A\u00f1adimos los cambios en staging y en esta ocasi\u00f3n, y tal como nos indicaba en el mensaje anterior, no tenemos que hacer git commit sino continuar con el rebase : $ git add lib/hola.php $ git status rebase in progress; onto 269eaca You are currently rebasing branch 'hola' on '269eaca'. (all conflicts fixed: run \"git rebase --continue\") Changes to be committed: (use \"git reset HEAD <file>...\" to unstage) modified: lib/hola.php $ git rebase --continue Applying: hola usa la clase HolaMundo Y ahora vemos que nuestro \u00e1rbol tiene un aspecto distinto, mucho m\u00e1s limpio: $ git hist --all * 9862f33 2013-06-16 | hola usa la clase HolaMundo (HEAD -> hola) [Sergio G\u00f3mez] * 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez] * 9c85275 2013-06-16 | Programa interactivo (master) [Sergio G\u00f3mez] * c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez] * 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez] * 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez] * fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez] * 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez] * efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez] * e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez] Lo que hace rebase es volver a aplicar todos los cambios a la rama m\u00e1ster, desde su nodo m\u00e1s reciente. Eso significa que se modifica el orden o la historia de creaci\u00f3n de los cambios. Por eso rebase no debe usarse si el orden es importante o si la rama es compartida.","title":"Rebasing vs Merging"},{"location":"ramas/#mezclando-con-la-rama-master","text":"Ya hemos terminado de implementar los cambios en nuestra rama secundaria y es hora de llevar los cambios a la rama principal. Usamos git merge para hacer una fusi\u00f3n normal: $ git checkout master Switched to branch 'master' $ git merge hola Updating c3e65d0..491f1d2 Fast-forward lib/HolaMundo.php | 16 ++++++++++++++++ lib/hola.php | 4 +++- 2 files changed, 19 insertions(+), 1 deletion(-) create mode 100644 lib/HolaMundo.php $ git hist --all * 9862f33 2013-06-16 | hola usa la clase HolaMundo (HEAD -> master, hola) [Sergio G\u00f3mez] * 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez] * 9c85275 2013-06-16 | Programa interactivo [Sergio G\u00f3mez] * c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez] * 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez] * 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez] * fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez] * 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez] * efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez] * e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez] Vemos que indica que el tipo de fusi\u00f3n es fast-forward . Este tipo de fusi\u00f3n tiene el problema que no deja rastro de la fusi\u00f3n, por eso suele ser recomendable usar el par\u00e1metro --no-ff para que quede constancia siempre de que se ha fusionado una rama con otra. Vamos a volver a probar ahora sin hacer fast-forward . Reseteamos master al estado \"Programa interactivo\" . $ git reset --hard 9c85275 $ git hist --all * 9862f33 2013-06-16 | hola usa la clase HolaMundo (HEAD -> hola) [Sergio G\u00f3mez] * 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez] * 9c85275 2013-06-16 | Programa interactivo (master) [Sergio G\u00f3mez] * c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez] * 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez] * 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez] * fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez] * 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez] * efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez] * e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez] Vemos que estamos como en el final de la secci\u00f3n anterior, as\u00ed que ahora mezclamos: $ git merge -m \"Aplicando los cambios de la rama hola\" --no-ff hola Merge made by the 'recursive' strategy. lib/HolaMundo.php | 16 ++++++++++++++++ lib/hola.php | 4 +++- 2 files changed, 19 insertions(+), 1 deletion(-) create mode 100644 lib/HolaMundo.php $ git hist --all * 2eab8ca 2013-06-16 | Aplicando los cambios de la rama hola (HEAD -> master) [Sergio Gomez] *\\ | * 9862f33 2013-06-16 | hola usa la clase HolaMundo (hola) [Sergio G\u00f3mez] | * 6932156 2013-06-16 | A\u00f1adida la clase HolaMundo [Sergio G\u00f3mez] |/ * 9c85275 2013-06-16 | Programa interactivo (master) [Sergio G\u00f3mez] * c3e65d0 2013-06-16 | A\u00f1adido README.md [Sergio G\u00f3mez] * 81c6e93 2013-06-16 | Movido hola.php a lib [Sergio G\u00f3mez] * 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email [Sergio G\u00f3mez] * fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez] * 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez] * efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez] * e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez] En la siguiente imagen se puede ver la diferencia:","title":"Mezclando con la rama master"},{"location":"referencias/","text":"Referencias \u00b6 Documentaci\u00f3n oficial en ingl\u00e9s . Documentaci\u00f3n oficial en espa\u00f1ol (quiz\u00e1s incompleta) . Curso de Git (ingl\u00e9s) . La mayor\u00eda de la documentaci\u00f3n de este manual est\u00e1 basada en este curso. Curso interactivo de Git (ingl\u00e9s) . P\u00e1gina de referencia de todas las \u00f3rdenes de Git (ingl\u00e9s) . Chuleta con las \u00f3rdenes m\u00e1s usuales de Git . Gitmagic (ingles y espa\u00f1ol). Otro manual de Git Art\u00edculo t\u00e9cnico: Un modelo exitoso de ramificaci\u00f3n en Git . Curso detallado y gratuito sobre Git y github Otra guia r\u00e1pida de git Gu\u00eda de estilos seg\u00fan Udacity Flujo de trabajo de Gitflow","title":"Referencias"},{"location":"referencias/#referencias","text":"Documentaci\u00f3n oficial en ingl\u00e9s . Documentaci\u00f3n oficial en espa\u00f1ol (quiz\u00e1s incompleta) . Curso de Git (ingl\u00e9s) . La mayor\u00eda de la documentaci\u00f3n de este manual est\u00e1 basada en este curso. Curso interactivo de Git (ingl\u00e9s) . P\u00e1gina de referencia de todas las \u00f3rdenes de Git (ingl\u00e9s) . Chuleta con las \u00f3rdenes m\u00e1s usuales de Git . Gitmagic (ingles y espa\u00f1ol). Otro manual de Git Art\u00edculo t\u00e9cnico: Un modelo exitoso de ramificaci\u00f3n en Git . Curso detallado y gratuito sobre Git y github Otra guia r\u00e1pida de git Gu\u00eda de estilos seg\u00fan Udacity Flujo de trabajo de Gitflow","title":"Referencias"},{"location":"usoavanzado/","text":"Uso avanzado de Git \u00b6 Deshacer cambios \u00b6 Deshaciendo cambios antes de la fase de staging. \u00b6 Volvemos a la rama m\u00e1ster y vamos a modificar el comentario que pusimos: $ git checkout master Previous HEAD position was 3283e0d... Se a\u00f1ade un par\u00e1metro por defecto Switched to branch 'master' Modificamos hola.php de la siguiente manera: <?php // Este comentario est\u00e1 mal y hay que borrarlo $nombre = isset ( $argv [ 1 ]) ? $argv [ 1 ] : \"Mundo\" ; @ print \"Hola, { $nombre } \\n \" ; Y comprobamos: $ git status # On branch master # Changes not staged for commit: # (use \"git add <file>...\" to update what will be committed) # (use \"git checkout -- <file>...\" to discard changes in working directory) # # modified: hola.php # no changes added to commit (use \"git add\" and/or \"git commit -a\") El mismo Git nos indica que debemos hacer para a\u00f1adir los cambios o para deshacerlos: $ git checkout hola.php $ git status # On branch master nothing to commit, working directory clean $ cat hola.php <?php // El nombre por defecto es Mundo $nombre = isset($argv[1]) ? $argv[1] : \"Mundo\"; @print \"Hola, {$nombre}\\n\"; Deshaciendo cambios antes del commit \u00b6 Vamos a hacer lo mismo que la vez anterior, pero esta vez s\u00ed a\u00f1adiremos el cambio al staging (sin hacer commit ). As\u00ed que volvemos a modificar hola.php igual que la anterior ocasi\u00f3n: <?php // Este comentario est\u00e1 mal y hay que borrarlo $nombre = isset ( $argv [ 1 ]) ? $argv [ 1 ] : \"Mundo\" ; @ print \"Hola, { $nombre } \\n \" ; Y lo a\u00f1adimos al staging $ git add hola.php $ git status # On branch master # Changes to be committed: # (use \"git reset HEAD <file>...\" to unstage) # # modified: hola.php # De nuevo, Git nos indica qu\u00e9 debemos hacer para deshacer el cambio: $ git reset HEAD hola.php Unstaged changes after reset: M hola.php $ git status # On branch master # Changes not staged for commit: # (use \"git add <file>...\" to update what will be committed) # (use \"git checkout -- <file>...\" to discard changes in working directory) # # modified: hola.php # no changes added to commit (use \"git add\" and/or \"git commit -a\") $ git checkout hola.php Y ya tenemos nuestro repositorio limpio otra vez. Como vemos hay que hacerlo en dos pasos: uno para borrar los datos del staging y otro para restaurar la copia de trabajo. Deshaciendo commits no deseados. \u00b6 Si a pesar de todo hemos hecho un commit y nos hemos equivocado, podemos deshacerlo con la orden git revert . Modificamos otra vez el archivo como antes: <?php // Este comentario est\u00e1 mal y hay que borrarlo $nombre = isset ( $argv [ 1 ]) ? $argv [ 1 ] : \"Mundo\" ; @ print \"Hola, { $nombre } \\n \" ; Pero ahora s\u00ed hacemos commit: $ git add hola.php $ git commit -m \"Ups... este commit est\u00e1 mal.\" master 5a5d067] Ups... este commit est\u00e1 mal 1 file changed, 1 insertion(+), 1 deletion(-) Bien, una vez confirmado el cambio, vamos a deshacer el cambio con la orden git revert : $ git revert HEAD --no-edit [master 817407b] Revert \"Ups... este commit est\u00e1 mal\" 1 file changed, 1 insertion(+), 1 deletion(-) $ git hist * 817407b 2013-06-16 | Revert \"Ups... este commit est\u00e1 mal\" (HEAD, master) [Sergio G\u00f3mez] * 5a5d067 2013-06-16 | Ups... este commit est\u00e1 mal [Sergio G\u00f3mez] * fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez] * 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez] * efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez] * e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez] Borrar commits de una rama \u00b6 El anterior apartado revierte un commit, pero deja huella en el historial de cambios. Para hacer que no aparezca hay que usar la orden git reset . $ git reset --hard v1 HEAD is now at fd4da94 Se a\u00f1ade un comentario al cambio del valor por defecto $ git hist * fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (HEAD, tag: v1, master) [Sergio G\u00f3me * 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez] * efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez] * e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez] El resto de cambios no se han borrado (a\u00fan), simplemente no est\u00e1n accesibles porque git no sabe como referenciarlos. Si sabemos su hash podemos acceder a\u00fan a ellos. Pasado un tiempo, eventualmente Git tiene un recolector de basura que los borrar\u00e1. Se puede evitar etiquetando el estado final. Danger La orden reset es una operaci\u00f3n delicada. Debe evitarse si no se sabe bien lo que se est\u00e1 haciendo, sobre todo cuando se trabaja en repositorios compartidos, porque podr\u00edamos alterar la historia de cambios lo cual puede provocar problemas de sincronizaci\u00f3n. Modificar un commit \u00b6 Esto se usa cuando hemos olvidado a\u00f1adir un cambio a un commit que acabamos de realizar. Tenemos nuestro archivo hola.php de la siguiente manera: <?php // Autor: Sergio G\u00f3mez // El nombre por defecto es Mundo $nombre = isset ( $argv [ 1 ]) ? $argv [ 1 ] : \"Mundo\" ; @ print \"Hola, { $nombre } \\n \" ; Y lo confirmamos: $ git commit -a -m \"A\u00f1adido el autor del programa\" [master cf405c1] A\u00f1adido el autor del programa 1 file changed, 1 insertion(+) Tip El par\u00e1metro -a hace un git add antes de hacer commit de todos los archivos modificados o borrados (de los nuevos no), con lo que nos ahorramos un paso. Ahora nos percatamos que se nos ha olvidado poner el correo electr\u00f3nico. As\u00ed que volvemos a modificar nuestro archivo: <?php // Autor: Sergio G\u00f3mez <sergio@uco.es> // El nombre por defecto es Mundo $nombre = isset ( $argv [ 1 ]) ? $argv [ 1 ] : \"Mundo\" ; @ print \"Hola, { $nombre } \\n \" ; Y en esta ocasi\u00f3n usamos commit --amend que nos permite modificar el \u00faltimo estado confirmado, sustituy\u00e9ndolo por el estado actual: $ git add hola.php $ git commit --amend -m \"A\u00f1adido el autor del programa y su email\" [master 96a39df] A\u00f1adido el autor del programa y su email 1 file changed, 1 insertion(+) $ git hist * 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email (HEAD, master) [Sergio G\u00f3mez] * fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez] * 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez] * efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez] * e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez] Danger Nunca modifiques un commit que ya hayas sincronizado con otro repositorio o que hayas recibido de \u00e9l. Estar\u00edas alterando la historia de cambios y provocar\u00edas problemas de sincronizaci\u00f3n. Moviendo y borrando archivos \u00b6 Mover un archivo a otro directorio con git \u00b6 Para mover archivos usaremos la orden git mv : $ mkdir lib $ git mv hola.php lib $ git status # On branch master # Changes to be committed: # (use \"git reset HEAD <file>...\" to unstage) # # renamed: hola.php -> lib/hola.php # Mover y borrar archivos. \u00b6 Pod\u00edamos haber hecho el paso anterior con la \u00f3rden del sistema mv y el resultado hubiera sido el mismo. Lo siguiente es a modo de ejemplo y no es necesario que lo ejecutes: $ mkdir lib $ mv hola.php lib $ git add lib/hola.php $ git rm hola.php Y, ahora s\u00ed, ya podemos guardar los cambios: $ git commit -m \"Movido hola.php a lib.\" [master 8c2a509] Movido hola.php a lib. 1 file changed, 0 insertions(+), 0 deletions(-) rename hola.php => lib/hola.php (100%)","title":"Uso avanzado de Git"},{"location":"usoavanzado/#uso-avanzado-de-git","text":"","title":"Uso avanzado de Git"},{"location":"usoavanzado/#deshacer-cambios","text":"","title":"Deshacer cambios"},{"location":"usoavanzado/#deshaciendo-cambios-antes-de-la-fase-de-staging","text":"Volvemos a la rama m\u00e1ster y vamos a modificar el comentario que pusimos: $ git checkout master Previous HEAD position was 3283e0d... Se a\u00f1ade un par\u00e1metro por defecto Switched to branch 'master' Modificamos hola.php de la siguiente manera: <?php // Este comentario est\u00e1 mal y hay que borrarlo $nombre = isset ( $argv [ 1 ]) ? $argv [ 1 ] : \"Mundo\" ; @ print \"Hola, { $nombre } \\n \" ; Y comprobamos: $ git status # On branch master # Changes not staged for commit: # (use \"git add <file>...\" to update what will be committed) # (use \"git checkout -- <file>...\" to discard changes in working directory) # # modified: hola.php # no changes added to commit (use \"git add\" and/or \"git commit -a\") El mismo Git nos indica que debemos hacer para a\u00f1adir los cambios o para deshacerlos: $ git checkout hola.php $ git status # On branch master nothing to commit, working directory clean $ cat hola.php <?php // El nombre por defecto es Mundo $nombre = isset($argv[1]) ? $argv[1] : \"Mundo\"; @print \"Hola, {$nombre}\\n\";","title":"Deshaciendo cambios antes de la fase de staging."},{"location":"usoavanzado/#deshaciendo-cambios-antes-del-commit","text":"Vamos a hacer lo mismo que la vez anterior, pero esta vez s\u00ed a\u00f1adiremos el cambio al staging (sin hacer commit ). As\u00ed que volvemos a modificar hola.php igual que la anterior ocasi\u00f3n: <?php // Este comentario est\u00e1 mal y hay que borrarlo $nombre = isset ( $argv [ 1 ]) ? $argv [ 1 ] : \"Mundo\" ; @ print \"Hola, { $nombre } \\n \" ; Y lo a\u00f1adimos al staging $ git add hola.php $ git status # On branch master # Changes to be committed: # (use \"git reset HEAD <file>...\" to unstage) # # modified: hola.php # De nuevo, Git nos indica qu\u00e9 debemos hacer para deshacer el cambio: $ git reset HEAD hola.php Unstaged changes after reset: M hola.php $ git status # On branch master # Changes not staged for commit: # (use \"git add <file>...\" to update what will be committed) # (use \"git checkout -- <file>...\" to discard changes in working directory) # # modified: hola.php # no changes added to commit (use \"git add\" and/or \"git commit -a\") $ git checkout hola.php Y ya tenemos nuestro repositorio limpio otra vez. Como vemos hay que hacerlo en dos pasos: uno para borrar los datos del staging y otro para restaurar la copia de trabajo.","title":"Deshaciendo cambios antes del commit"},{"location":"usoavanzado/#deshaciendo-commits-no-deseados","text":"Si a pesar de todo hemos hecho un commit y nos hemos equivocado, podemos deshacerlo con la orden git revert . Modificamos otra vez el archivo como antes: <?php // Este comentario est\u00e1 mal y hay que borrarlo $nombre = isset ( $argv [ 1 ]) ? $argv [ 1 ] : \"Mundo\" ; @ print \"Hola, { $nombre } \\n \" ; Pero ahora s\u00ed hacemos commit: $ git add hola.php $ git commit -m \"Ups... este commit est\u00e1 mal.\" master 5a5d067] Ups... este commit est\u00e1 mal 1 file changed, 1 insertion(+), 1 deletion(-) Bien, una vez confirmado el cambio, vamos a deshacer el cambio con la orden git revert : $ git revert HEAD --no-edit [master 817407b] Revert \"Ups... este commit est\u00e1 mal\" 1 file changed, 1 insertion(+), 1 deletion(-) $ git hist * 817407b 2013-06-16 | Revert \"Ups... este commit est\u00e1 mal\" (HEAD, master) [Sergio G\u00f3mez] * 5a5d067 2013-06-16 | Ups... este commit est\u00e1 mal [Sergio G\u00f3mez] * fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez] * 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez] * efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez] * e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]","title":"Deshaciendo commits no deseados."},{"location":"usoavanzado/#borrar-commits-de-una-rama","text":"El anterior apartado revierte un commit, pero deja huella en el historial de cambios. Para hacer que no aparezca hay que usar la orden git reset . $ git reset --hard v1 HEAD is now at fd4da94 Se a\u00f1ade un comentario al cambio del valor por defecto $ git hist * fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (HEAD, tag: v1, master) [Sergio G\u00f3me * 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez] * efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez] * e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez] El resto de cambios no se han borrado (a\u00fan), simplemente no est\u00e1n accesibles porque git no sabe como referenciarlos. Si sabemos su hash podemos acceder a\u00fan a ellos. Pasado un tiempo, eventualmente Git tiene un recolector de basura que los borrar\u00e1. Se puede evitar etiquetando el estado final. Danger La orden reset es una operaci\u00f3n delicada. Debe evitarse si no se sabe bien lo que se est\u00e1 haciendo, sobre todo cuando se trabaja en repositorios compartidos, porque podr\u00edamos alterar la historia de cambios lo cual puede provocar problemas de sincronizaci\u00f3n.","title":"Borrar commits de una rama"},{"location":"usoavanzado/#modificar-un-commit","text":"Esto se usa cuando hemos olvidado a\u00f1adir un cambio a un commit que acabamos de realizar. Tenemos nuestro archivo hola.php de la siguiente manera: <?php // Autor: Sergio G\u00f3mez // El nombre por defecto es Mundo $nombre = isset ( $argv [ 1 ]) ? $argv [ 1 ] : \"Mundo\" ; @ print \"Hola, { $nombre } \\n \" ; Y lo confirmamos: $ git commit -a -m \"A\u00f1adido el autor del programa\" [master cf405c1] A\u00f1adido el autor del programa 1 file changed, 1 insertion(+) Tip El par\u00e1metro -a hace un git add antes de hacer commit de todos los archivos modificados o borrados (de los nuevos no), con lo que nos ahorramos un paso. Ahora nos percatamos que se nos ha olvidado poner el correo electr\u00f3nico. As\u00ed que volvemos a modificar nuestro archivo: <?php // Autor: Sergio G\u00f3mez <sergio@uco.es> // El nombre por defecto es Mundo $nombre = isset ( $argv [ 1 ]) ? $argv [ 1 ] : \"Mundo\" ; @ print \"Hola, { $nombre } \\n \" ; Y en esta ocasi\u00f3n usamos commit --amend que nos permite modificar el \u00faltimo estado confirmado, sustituy\u00e9ndolo por el estado actual: $ git add hola.php $ git commit --amend -m \"A\u00f1adido el autor del programa y su email\" [master 96a39df] A\u00f1adido el autor del programa y su email 1 file changed, 1 insertion(+) $ git hist * 96a39df 2013-06-16 | A\u00f1adido el autor del programa y su email (HEAD, master) [Sergio G\u00f3mez] * fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1) [Sergio G\u00f3mez] * 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (tag: v1-beta) [Sergio G\u00f3mez] * efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez] * e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez] Danger Nunca modifiques un commit que ya hayas sincronizado con otro repositorio o que hayas recibido de \u00e9l. Estar\u00edas alterando la historia de cambios y provocar\u00edas problemas de sincronizaci\u00f3n.","title":"Modificar un commit"},{"location":"usoavanzado/#moviendo-y-borrando-archivos","text":"","title":"Moviendo y borrando archivos"},{"location":"usoavanzado/#mover-un-archivo-a-otro-directorio-con-git","text":"Para mover archivos usaremos la orden git mv : $ mkdir lib $ git mv hola.php lib $ git status # On branch master # Changes to be committed: # (use \"git reset HEAD <file>...\" to unstage) # # renamed: hola.php -> lib/hola.php #","title":"Mover un archivo a otro directorio con git"},{"location":"usoavanzado/#mover-y-borrar-archivos","text":"Pod\u00edamos haber hecho el paso anterior con la \u00f3rden del sistema mv y el resultado hubiera sido el mismo. Lo siguiente es a modo de ejemplo y no es necesario que lo ejecutes: $ mkdir lib $ mv hola.php lib $ git add lib/hola.php $ git rm hola.php Y, ahora s\u00ed, ya podemos guardar los cambios: $ git commit -m \"Movido hola.php a lib.\" [master 8c2a509] Movido hola.php a lib. 1 file changed, 0 insertions(+), 0 deletions(-) rename hola.php => lib/hola.php (100%)","title":"Mover y borrar archivos."},{"location":"usobasico/","text":"Uso b\u00e1sico de Git \u00b6 Crear un proyecto \u00b6 Crear un programa \"Hola Mundo\" \u00b6 Creamos un directorio donde colocar el c\u00f3digo $ mkdir curso-de-git $ cd curso-de-git Creamos un fichero hola.php que muestre Hola Mundo. <?php echo \"Hola Mundo \\n \" ; Crear el repositorio \u00b6 Para crear un nuevo repositorio se usa la orden git init $ git init Initialized empty Git repository in /home/cc0gobas/git/curso-de-git/.git/ A\u00f1adir la aplicaci\u00f3n \u00b6 Vamos a almacenar el archivo que hemos creado en el repositorio para poder trabajar, despu\u00e9s explicaremos para qu\u00e9 sirve cada orden. $ git add hola.php $ git commit -m \"Creaci\u00f3n del proyecto\" [master (root-commit) e19f2c1] Creaci\u00f3n del proyecto 1 file changed, 2 insertions(+) create mode 100644 hola.php Comprobar el estado del repositorio \u00b6 Con la orden git status podemos ver en qu\u00e9 estado se encuentran los archivos de nuestro repositorio. $ git status # On branch master nothing to commit (working directory clean) Si modificamos el archivo hola.php : <?php @ print \"Hola { $argv [ 1 ] } \\n \" ; Y volvemos a comprobar el estado del repositorio: $ git status # On branch master # Changes not staged for commit: # (use \"git add <file>...\" to update what will be committed) # (use \"git checkout -- <file>...\" to discard changes in working directory) # # modified: hola.php # no changes added to commit (use \"git add\" and/or \"git commit -a\") A\u00f1adir cambios \u00b6 Con la orden git add indicamos a git que prepare los cambios para que sean almacenados. $ git add hola.php $ git status # On branch master # Changes to be committed: # (use \"git reset HEAD <file>...\" to unstage) # # modified: hola.php # Confirmar los cambios \u00b6 Con la orden git commit confirmamos los cambios definitivamente, lo que hace que se guarden permanentemente en nuestro repositorio. $ git commit -m \"Parametrizaci\u00f3n del programa\" [master efc252e] Parametrizaci\u00f3n del programa 1 file changed, 1 insertion(+), 1 deletion(-) $ git status # On branch master nothing to commit (working directory clean) Diferencias entre workdir y staging . \u00b6 Modificamos nuestra aplicaci\u00f3n para que soporte un par\u00e1metro por defecto y a\u00f1adimos los cambios. <?php $nombre = isset ( $argv [ 1 ]) ? $argv [ 1 ] : \"Mundo\" ; @ print \"Hola, { $nombre } \\n \" ; Este vez a\u00f1adimos los cambios a la fase de staging pero sin confirmarlos ( commit ). git add hola.php Volvemos a modificar el programa para indicar con un comentario lo que hemos hecho. <?php // El nombre por defecto es Mundo $nombre = isset ( $argv [ 1 ]) ? $argv [ 1 ] : \"Mundo\" ; @ print \"Hola, { $nombre } \\n \" ; Y vemos el estado en el que est\u00e1 el repositorio $ git status # On branch master # Changes to be committed: # (use \"git reset HEAD <file>...\" to unstage) # # modified: hola.php # # Changes not staged for commit: # (use \"git add <file>...\" to update what will be committed) # (use \"git checkout -- <file>...\" to discard changes in working directory) # # modified: hola.php # Podemos ver como aparecen el archivo hola.php dos veces. El primero est\u00e1 preparado para ser confirmado y est\u00e1 almacenado en la zona de staging . El segundo indica que el directorio hola.php est\u00e1 modificado otra vez en la zona de trabajo ( workdir ). Warning Si volvieramos a hacer un git add hola.php sobreescribir\u00edamos los cambios previos que hab\u00eda en la zona de staging . Almacenamos los cambios por separado: $ git commit -m \"Se a\u00f1ade un par\u00e1metro por defecto\" [master 3283e0d] Se a\u00f1ade un par\u00e1metro por defecto 1 file changed, 2 insertions(+), 1 deletion(-) $ git status # On branch master # Changes not staged for commit: # (use \"git add <file>...\" to update what will be committed) # (use \"git checkout -- <file>...\" to discard changes in working directory) # # modified: hola.php # no changes added to commit (use \"git add\" and/or \"git commit -a\") $ git add . $ git status # On branch master # Changes to be committed: # (use \"git reset HEAD <file>...\" to unstage) # # modified: hola.php # $ git commit -m \"Se a\u00f1ade un comentario al cambio del valor por defecto\" [master fd4da94] Se a\u00f1ade un comentario al cambio del valor por defecto 1 file changed, 1 insertion(+) Info El valor \".\" despues de git add indica que se a\u00f1adan todos los archivos de forma recursiva. Warning Cuidado cuando uses git add . aseg\u00farate de que no est\u00e1s a\u00f1adiendo archivos que no quieres a\u00f1adir. Ignorando archivos \u00b6 La orden git add . o git add nombre_directorio es muy c\u00f3moda, ya que nos permite a\u00f1adir todos los archivos del proyecto o todos los contenidos en un directorio y sus subdirectorios. Es mucho m\u00e1s r\u00e1pido que tener que ir a\u00f1adi\u00e9ndolos uno por uno. El problema es que, si no se tiene cuidado, se puede terminar por a\u00f1adir archivos innecesarios o con informaci\u00f3n sensible. Por lo general se debe evitar a\u00f1adir archivos que se hayan generado como producto de la compilaci\u00f3n del proyecto, los que generen los entornos de desarrollo (archivos de configuraci\u00f3n y temporales) y aquellos que contentan informaci\u00f3n sensible, como contrase\u00f1as o tokens de autenticaci\u00f3n. Por ejemplo, en un proyecto de C/C++ , los archivos objeto no deben incluirse, solo los que contengan c\u00f3digo fuente y los make que los generen. Para indicarle a git que debe ignorar un archivo, se puede crear un fichero llamado .gitignore , bien en la ra\u00edz del proyecto o en los subdirectorios que queramos. Dicho fichero puede contener patrones, uno en cada l\u00ednea, que especiquen qu\u00e9 archivos deben ignorarse. El formato es el siguiente: # .gitignore dir1/ # ignora todo lo que contenga el directorio dir1 !dir1/info.txt # El operador ! excluye del ignore a dir1/info.txt (s\u00ed se guardar\u00eda) dir2/*.txt # ignora todos los archivos txt que hay en el directorio dir2 dir3/**/*.txt # ignora todos los archivos txt que hay en el dir3 y sus subdirectorios *.o # ignora todos los archivos con extensi\u00f3n .o en todos los directorios Cada tipo de proyecto genera sus ficheros temporales, as\u00ed que para cada proyecto hay un .gitignore apropiado. Existen repositorios que ya tienen creadas plantillas. Pod\u00e9is encontrar uno en https://github.com/github/gitignore Ignorando archivos globalmente \u00b6 Si bien, los archivos que hemos metido en .gitignore , deben ser aquellos ficheros temporales o de configuraci\u00f3n que se pueden crear durante las fases de compilaci\u00f3n o ejecuci\u00f3n del programa, en ocasiones habr\u00e1 otros ficheros que tampoco debemos introducir en el repositorio y que son recurrentes en todos los proyectos. En dicho caso, es m\u00e1s \u00fatil tener un gitignore que sea global a todos nuestros proyectos. Esta configuraci\u00f3n ser\u00eda complementaria a la que ya tenemos. Ejemplos de lo que se puede ignorar de forma global son los ficheros temporales del sistema operativo ( *~ , .nfs* ) y los que generan los entornos de desarrollo. Para indicar a git que queremos tener un fichero de gitignore global, tenemos que configurarlo con la siguiente orden: git config --global core.excludesfile $HOME/.gitignore_global Ahora podemos crear un archivo llamado .gitignore_global en la ra\u00edz de nuestra cuenta con este contenido: # Compiled source # ################### *.com *.class *.dll *.exe *.o *.so # Packages # ############ # it's better to unpack these files and commit the raw source # git has its own built in compression methods *.7z *.dmg *.gz *.iso *.jar *.rar *.tar *.zip # Logs and databases # ###################### *.log *.sql *.sqlite # OS generated files # ###################### .DS_Store .DS_Store? ._* .Spotlight-V100 .Trashes ehthumbs.db Thumbs.db *~ *.swp # IDEs # ###################### .idea .settings/ .classpath .project Trabajando con el historial \u00b6 Observando los cambios \u00b6 Con la orden git log podemos ver todos los cambios que hemos hecho: $ git log commit fd4da946326fbe8b24e89282ad25a71721bf40f6 Author: Sergio G\u00f3mez <sergio@uco.es> Date: Sun Jun 16 12:51:01 2013 +0200 Se a\u00f1ade un comentario al cambio del valor por defecto commit 3283e0d306c8d42d55ffcb64e456f10510df8177 Author: Sergio G\u00f3mez <sergio@uco.es> Date: Sun Jun 16 12:50:00 2013 +0200 Se a\u00f1ade un par\u00e1metro por defecto commit efc252e11939351505a426a6e1aa5bb7dc1dd7c0 Author: Sergio G\u00f3mez <sergio@uco.es> Date: Sun Jun 16 12:13:26 2013 +0200 Parametrizaci\u00f3n del programa commit e19f2c1701069d9d1159e9ee21acaa1bbc47d264 Author: Sergio G\u00f3mez <sergio@uco.es> Date: Sun Jun 16 11:55:23 2013 +0200 Creaci\u00f3n del proyecto Tambi\u00e9n es posible ver versiones abreviadas o limitadas, dependiendo de los par\u00e1metros: $ git log --oneline fd4da94 Se a\u00f1ade un comentario al cambio del valor por defecto 3283e0d Se a\u00f1ade un par\u00e1metro por defecto efc252e Parametrizaci\u00f3n del programa e19f2c1 Creaci\u00f3n del proyecto git log --oneline --max-count=2 git log --oneline --since='5 minutes ago' git log --oneline --until='5 minutes ago' git log --oneline --author=sergio git log --oneline --all Una versi\u00f3n muy \u00fatil de git log es la siguiente, pues nos permite ver en que lugares est\u00e1 master y HEAD, entre otras cosas: $ git log --pretty=format:'%h %ad | %s%d [%an]' --graph --date=short * fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (HEAD, master) [Sergio G\u00f3mez] * 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto [Sergio G\u00f3mez] * efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez] * e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez] Crear alias \u00b6 Como estas \u00f3rdenes son demasiado largas, Git nos permite crear alias para crear nuevas \u00f3rdenes parametrizadas. Para ello podemos configurar nuestro entorno con la orden git config de la siguiente manera: git config --global alias.hist \"log --pretty=format:'%h %ad | %s%d [%an]' --graph --date=short\" Example Puedes configurar incluso alias para abreviar comandos. Algunos ejemplos de alias \u00fatiles: git config --global alias.br branch git config --global alias.co checkout git config --global alias.ci commit git config --global alias.st \"status -u\" git config --global alias.cane \"commit --amend --no-edit\" Recuperando versiones anteriores \u00b6 Cada cambio es etiquetado por un hash, para poder regresar a ese momento del estado del proyecto se usa la orden git checkout . $ git checkout e19f2c1 Note: checking out 'e19f2c1'. You are in 'detached HEAD' state. You can look around, make experimental changes and commit them, and you can discard any commits you make in this state without impacting any branches by performing another checkout. If you want to create a new branch to retain commits you create, you may do so (now or later) by using -b with the checkout command again. Example: git checkout -b new_branch_name HEAD is now at e19f2c1... Creaci\u00f3n del proyecto $ cat hola.php <?php echo \"Hello, World\\n\"; El aviso que nos sale nos indica que estamos en un estado donde no trabajamos en ninguna rama concreta. Eso significa que los cambios que hagamos podr\u00edan \"perderse\" porque si no son guardados en una nueva rama, en principio no podr\u00edamos volver a recuperarlos. Hay que pensar que Git es como un \u00e1rbol donde un nodo tiene informaci\u00f3n de su nodo padre, no de sus nodos hijos, con lo que siempre necesitar\u00edamos informaci\u00f3n de d\u00f3nde se encuentran los nodos finales o de otra manera no podr\u00edamos acceder a ellos. Volver a la \u00faltima versi\u00f3n de la rama master. \u00b6 Usamos git checkout indicando el nombre de la rama: $ git checkout master Previous HEAD position was e19f2c1... Creaci\u00f3n del proyecto Etiquetando versiones \u00b6 Para poder recuperar versiones concretas en la historia del repositorio, podemos etiquetarlas, lo cual es m\u00e1s facil que usar un hash. Para eso usaremos la orden git tag . $ git tag v1 Ahora vamos a etiquetar la versi\u00f3n inmediatamente anterior como v1-beta. Para ello podemos usar los modificadores ^ o ~ que nos llevar\u00e1n a un ancestro determinado. Las siguientes dos \u00f3rdenes son equivalentes: $ git checkout v1^ $ git checkout v1~1 $ git tag v1-beta Si ejecutamos la orden sin par\u00e1metros nos mostrar\u00e1 todas las etiquetas existentes. $ git tag v1 v1-beta Y para verlas en el historial: $ git hist master --all * fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1, master) [Sergio G\u00f3mez] * 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (HEAD, tag: v1-beta) [Sergio G\u00f3mez] * efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez] * e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez] Borrar etiquetas \u00b6 Para borrar etiquetas: git tag -d nombre_etiqueta Visualizar cambios \u00b6 Para ver los cambios que se han realizado en el c\u00f3digo usamos la orden git diff . La orden sin especificar nada m\u00e1s, mostrar\u00e1 los cambios que no han sido a\u00f1adidos a\u00fan, es decir, todos los cambios que se han hecho antes de usar la orden git add . Despu\u00e9s se puede indicar un par\u00e1metro y dar\u00e1 los cambios entre la versi\u00f3n indicada y el estado actual. O para comparar dos versiones entre s\u00ed, se indica la m\u00e1s antigua y la m\u00e1s nueva. Ejemplo: $ git diff v1-beta v1 diff --git a/hola.php b/hola.php index a31e01f..25a35c0 100644 --- a/hola.php +++ b/hola.php @@ -1,3 +1,4 @@ <?php +// El nombre por defecto es Mundo $nombre = isset($argv[1]) ? $argv[1] : \"Mundo\"; @print \"Hola, {$nombre}\\n\";","title":"Uso b\u00e1sico de Git"},{"location":"usobasico/#uso-basico-de-git","text":"","title":"Uso b\u00e1sico de Git"},{"location":"usobasico/#crear-un-proyecto","text":"","title":"Crear un proyecto"},{"location":"usobasico/#crear-un-programa-hola-mundo","text":"Creamos un directorio donde colocar el c\u00f3digo $ mkdir curso-de-git $ cd curso-de-git Creamos un fichero hola.php que muestre Hola Mundo. <?php echo \"Hola Mundo \\n \" ;","title":"Crear un programa \"Hola Mundo\""},{"location":"usobasico/#crear-el-repositorio","text":"Para crear un nuevo repositorio se usa la orden git init $ git init Initialized empty Git repository in /home/cc0gobas/git/curso-de-git/.git/","title":"Crear el repositorio"},{"location":"usobasico/#anadir-la-aplicacion","text":"Vamos a almacenar el archivo que hemos creado en el repositorio para poder trabajar, despu\u00e9s explicaremos para qu\u00e9 sirve cada orden. $ git add hola.php $ git commit -m \"Creaci\u00f3n del proyecto\" [master (root-commit) e19f2c1] Creaci\u00f3n del proyecto 1 file changed, 2 insertions(+) create mode 100644 hola.php","title":"A\u00f1adir la aplicaci\u00f3n"},{"location":"usobasico/#comprobar-el-estado-del-repositorio","text":"Con la orden git status podemos ver en qu\u00e9 estado se encuentran los archivos de nuestro repositorio. $ git status # On branch master nothing to commit (working directory clean) Si modificamos el archivo hola.php : <?php @ print \"Hola { $argv [ 1 ] } \\n \" ; Y volvemos a comprobar el estado del repositorio: $ git status # On branch master # Changes not staged for commit: # (use \"git add <file>...\" to update what will be committed) # (use \"git checkout -- <file>...\" to discard changes in working directory) # # modified: hola.php # no changes added to commit (use \"git add\" and/or \"git commit -a\")","title":"Comprobar el estado del repositorio"},{"location":"usobasico/#anadir-cambios","text":"Con la orden git add indicamos a git que prepare los cambios para que sean almacenados. $ git add hola.php $ git status # On branch master # Changes to be committed: # (use \"git reset HEAD <file>...\" to unstage) # # modified: hola.php #","title":"A\u00f1adir cambios"},{"location":"usobasico/#confirmar-los-cambios","text":"Con la orden git commit confirmamos los cambios definitivamente, lo que hace que se guarden permanentemente en nuestro repositorio. $ git commit -m \"Parametrizaci\u00f3n del programa\" [master efc252e] Parametrizaci\u00f3n del programa 1 file changed, 1 insertion(+), 1 deletion(-) $ git status # On branch master nothing to commit (working directory clean)","title":"Confirmar los cambios"},{"location":"usobasico/#diferencias-entre-workdir-y-staging","text":"Modificamos nuestra aplicaci\u00f3n para que soporte un par\u00e1metro por defecto y a\u00f1adimos los cambios. <?php $nombre = isset ( $argv [ 1 ]) ? $argv [ 1 ] : \"Mundo\" ; @ print \"Hola, { $nombre } \\n \" ; Este vez a\u00f1adimos los cambios a la fase de staging pero sin confirmarlos ( commit ). git add hola.php Volvemos a modificar el programa para indicar con un comentario lo que hemos hecho. <?php // El nombre por defecto es Mundo $nombre = isset ( $argv [ 1 ]) ? $argv [ 1 ] : \"Mundo\" ; @ print \"Hola, { $nombre } \\n \" ; Y vemos el estado en el que est\u00e1 el repositorio $ git status # On branch master # Changes to be committed: # (use \"git reset HEAD <file>...\" to unstage) # # modified: hola.php # # Changes not staged for commit: # (use \"git add <file>...\" to update what will be committed) # (use \"git checkout -- <file>...\" to discard changes in working directory) # # modified: hola.php # Podemos ver como aparecen el archivo hola.php dos veces. El primero est\u00e1 preparado para ser confirmado y est\u00e1 almacenado en la zona de staging . El segundo indica que el directorio hola.php est\u00e1 modificado otra vez en la zona de trabajo ( workdir ). Warning Si volvieramos a hacer un git add hola.php sobreescribir\u00edamos los cambios previos que hab\u00eda en la zona de staging . Almacenamos los cambios por separado: $ git commit -m \"Se a\u00f1ade un par\u00e1metro por defecto\" [master 3283e0d] Se a\u00f1ade un par\u00e1metro por defecto 1 file changed, 2 insertions(+), 1 deletion(-) $ git status # On branch master # Changes not staged for commit: # (use \"git add <file>...\" to update what will be committed) # (use \"git checkout -- <file>...\" to discard changes in working directory) # # modified: hola.php # no changes added to commit (use \"git add\" and/or \"git commit -a\") $ git add . $ git status # On branch master # Changes to be committed: # (use \"git reset HEAD <file>...\" to unstage) # # modified: hola.php # $ git commit -m \"Se a\u00f1ade un comentario al cambio del valor por defecto\" [master fd4da94] Se a\u00f1ade un comentario al cambio del valor por defecto 1 file changed, 1 insertion(+) Info El valor \".\" despues de git add indica que se a\u00f1adan todos los archivos de forma recursiva. Warning Cuidado cuando uses git add . aseg\u00farate de que no est\u00e1s a\u00f1adiendo archivos que no quieres a\u00f1adir.","title":"Diferencias entre workdir y staging."},{"location":"usobasico/#ignorando-archivos","text":"La orden git add . o git add nombre_directorio es muy c\u00f3moda, ya que nos permite a\u00f1adir todos los archivos del proyecto o todos los contenidos en un directorio y sus subdirectorios. Es mucho m\u00e1s r\u00e1pido que tener que ir a\u00f1adi\u00e9ndolos uno por uno. El problema es que, si no se tiene cuidado, se puede terminar por a\u00f1adir archivos innecesarios o con informaci\u00f3n sensible. Por lo general se debe evitar a\u00f1adir archivos que se hayan generado como producto de la compilaci\u00f3n del proyecto, los que generen los entornos de desarrollo (archivos de configuraci\u00f3n y temporales) y aquellos que contentan informaci\u00f3n sensible, como contrase\u00f1as o tokens de autenticaci\u00f3n. Por ejemplo, en un proyecto de C/C++ , los archivos objeto no deben incluirse, solo los que contengan c\u00f3digo fuente y los make que los generen. Para indicarle a git que debe ignorar un archivo, se puede crear un fichero llamado .gitignore , bien en la ra\u00edz del proyecto o en los subdirectorios que queramos. Dicho fichero puede contener patrones, uno en cada l\u00ednea, que especiquen qu\u00e9 archivos deben ignorarse. El formato es el siguiente: # .gitignore dir1/ # ignora todo lo que contenga el directorio dir1 !dir1/info.txt # El operador ! excluye del ignore a dir1/info.txt (s\u00ed se guardar\u00eda) dir2/*.txt # ignora todos los archivos txt que hay en el directorio dir2 dir3/**/*.txt # ignora todos los archivos txt que hay en el dir3 y sus subdirectorios *.o # ignora todos los archivos con extensi\u00f3n .o en todos los directorios Cada tipo de proyecto genera sus ficheros temporales, as\u00ed que para cada proyecto hay un .gitignore apropiado. Existen repositorios que ya tienen creadas plantillas. Pod\u00e9is encontrar uno en https://github.com/github/gitignore","title":"Ignorando archivos"},{"location":"usobasico/#ignorando-archivos-globalmente","text":"Si bien, los archivos que hemos metido en .gitignore , deben ser aquellos ficheros temporales o de configuraci\u00f3n que se pueden crear durante las fases de compilaci\u00f3n o ejecuci\u00f3n del programa, en ocasiones habr\u00e1 otros ficheros que tampoco debemos introducir en el repositorio y que son recurrentes en todos los proyectos. En dicho caso, es m\u00e1s \u00fatil tener un gitignore que sea global a todos nuestros proyectos. Esta configuraci\u00f3n ser\u00eda complementaria a la que ya tenemos. Ejemplos de lo que se puede ignorar de forma global son los ficheros temporales del sistema operativo ( *~ , .nfs* ) y los que generan los entornos de desarrollo. Para indicar a git que queremos tener un fichero de gitignore global, tenemos que configurarlo con la siguiente orden: git config --global core.excludesfile $HOME/.gitignore_global Ahora podemos crear un archivo llamado .gitignore_global en la ra\u00edz de nuestra cuenta con este contenido: # Compiled source # ################### *.com *.class *.dll *.exe *.o *.so # Packages # ############ # it's better to unpack these files and commit the raw source # git has its own built in compression methods *.7z *.dmg *.gz *.iso *.jar *.rar *.tar *.zip # Logs and databases # ###################### *.log *.sql *.sqlite # OS generated files # ###################### .DS_Store .DS_Store? ._* .Spotlight-V100 .Trashes ehthumbs.db Thumbs.db *~ *.swp # IDEs # ###################### .idea .settings/ .classpath .project","title":"Ignorando archivos globalmente"},{"location":"usobasico/#trabajando-con-el-historial","text":"","title":"Trabajando con el historial"},{"location":"usobasico/#observando-los-cambios","text":"Con la orden git log podemos ver todos los cambios que hemos hecho: $ git log commit fd4da946326fbe8b24e89282ad25a71721bf40f6 Author: Sergio G\u00f3mez <sergio@uco.es> Date: Sun Jun 16 12:51:01 2013 +0200 Se a\u00f1ade un comentario al cambio del valor por defecto commit 3283e0d306c8d42d55ffcb64e456f10510df8177 Author: Sergio G\u00f3mez <sergio@uco.es> Date: Sun Jun 16 12:50:00 2013 +0200 Se a\u00f1ade un par\u00e1metro por defecto commit efc252e11939351505a426a6e1aa5bb7dc1dd7c0 Author: Sergio G\u00f3mez <sergio@uco.es> Date: Sun Jun 16 12:13:26 2013 +0200 Parametrizaci\u00f3n del programa commit e19f2c1701069d9d1159e9ee21acaa1bbc47d264 Author: Sergio G\u00f3mez <sergio@uco.es> Date: Sun Jun 16 11:55:23 2013 +0200 Creaci\u00f3n del proyecto Tambi\u00e9n es posible ver versiones abreviadas o limitadas, dependiendo de los par\u00e1metros: $ git log --oneline fd4da94 Se a\u00f1ade un comentario al cambio del valor por defecto 3283e0d Se a\u00f1ade un par\u00e1metro por defecto efc252e Parametrizaci\u00f3n del programa e19f2c1 Creaci\u00f3n del proyecto git log --oneline --max-count=2 git log --oneline --since='5 minutes ago' git log --oneline --until='5 minutes ago' git log --oneline --author=sergio git log --oneline --all Una versi\u00f3n muy \u00fatil de git log es la siguiente, pues nos permite ver en que lugares est\u00e1 master y HEAD, entre otras cosas: $ git log --pretty=format:'%h %ad | %s%d [%an]' --graph --date=short * fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (HEAD, master) [Sergio G\u00f3mez] * 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto [Sergio G\u00f3mez] * efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez] * e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]","title":"Observando los cambios"},{"location":"usobasico/#crear-alias","text":"Como estas \u00f3rdenes son demasiado largas, Git nos permite crear alias para crear nuevas \u00f3rdenes parametrizadas. Para ello podemos configurar nuestro entorno con la orden git config de la siguiente manera: git config --global alias.hist \"log --pretty=format:'%h %ad | %s%d [%an]' --graph --date=short\" Example Puedes configurar incluso alias para abreviar comandos. Algunos ejemplos de alias \u00fatiles: git config --global alias.br branch git config --global alias.co checkout git config --global alias.ci commit git config --global alias.st \"status -u\" git config --global alias.cane \"commit --amend --no-edit\"","title":"Crear alias"},{"location":"usobasico/#recuperando-versiones-anteriores","text":"Cada cambio es etiquetado por un hash, para poder regresar a ese momento del estado del proyecto se usa la orden git checkout . $ git checkout e19f2c1 Note: checking out 'e19f2c1'. You are in 'detached HEAD' state. You can look around, make experimental changes and commit them, and you can discard any commits you make in this state without impacting any branches by performing another checkout. If you want to create a new branch to retain commits you create, you may do so (now or later) by using -b with the checkout command again. Example: git checkout -b new_branch_name HEAD is now at e19f2c1... Creaci\u00f3n del proyecto $ cat hola.php <?php echo \"Hello, World\\n\"; El aviso que nos sale nos indica que estamos en un estado donde no trabajamos en ninguna rama concreta. Eso significa que los cambios que hagamos podr\u00edan \"perderse\" porque si no son guardados en una nueva rama, en principio no podr\u00edamos volver a recuperarlos. Hay que pensar que Git es como un \u00e1rbol donde un nodo tiene informaci\u00f3n de su nodo padre, no de sus nodos hijos, con lo que siempre necesitar\u00edamos informaci\u00f3n de d\u00f3nde se encuentran los nodos finales o de otra manera no podr\u00edamos acceder a ellos.","title":"Recuperando versiones anteriores"},{"location":"usobasico/#volver-a-la-ultima-version-de-la-rama-master","text":"Usamos git checkout indicando el nombre de la rama: $ git checkout master Previous HEAD position was e19f2c1... Creaci\u00f3n del proyecto","title":"Volver a la \u00faltima versi\u00f3n de la rama master."},{"location":"usobasico/#etiquetando-versiones","text":"Para poder recuperar versiones concretas en la historia del repositorio, podemos etiquetarlas, lo cual es m\u00e1s facil que usar un hash. Para eso usaremos la orden git tag . $ git tag v1 Ahora vamos a etiquetar la versi\u00f3n inmediatamente anterior como v1-beta. Para ello podemos usar los modificadores ^ o ~ que nos llevar\u00e1n a un ancestro determinado. Las siguientes dos \u00f3rdenes son equivalentes: $ git checkout v1^ $ git checkout v1~1 $ git tag v1-beta Si ejecutamos la orden sin par\u00e1metros nos mostrar\u00e1 todas las etiquetas existentes. $ git tag v1 v1-beta Y para verlas en el historial: $ git hist master --all * fd4da94 2013-06-16 | Se a\u00f1ade un comentario al cambio del valor por defecto (tag: v1, master) [Sergio G\u00f3mez] * 3283e0d 2013-06-16 | Se a\u00f1ade un par\u00e1metro por defecto (HEAD, tag: v1-beta) [Sergio G\u00f3mez] * efc252e 2013-06-16 | Parametrizaci\u00f3n del programa [Sergio G\u00f3mez] * e19f2c1 2013-06-16 | Creaci\u00f3n del proyecto [Sergio G\u00f3mez]","title":"Etiquetando versiones"},{"location":"usobasico/#borrar-etiquetas","text":"Para borrar etiquetas: git tag -d nombre_etiqueta","title":"Borrar etiquetas"},{"location":"usobasico/#visualizar-cambios","text":"Para ver los cambios que se han realizado en el c\u00f3digo usamos la orden git diff . La orden sin especificar nada m\u00e1s, mostrar\u00e1 los cambios que no han sido a\u00f1adidos a\u00fan, es decir, todos los cambios que se han hecho antes de usar la orden git add . Despu\u00e9s se puede indicar un par\u00e1metro y dar\u00e1 los cambios entre la versi\u00f3n indicada y el estado actual. O para comparar dos versiones entre s\u00ed, se indica la m\u00e1s antigua y la m\u00e1s nueva. Ejemplo: $ git diff v1-beta v1 diff --git a/hola.php b/hola.php index a31e01f..25a35c0 100644 --- a/hola.php +++ b/hola.php @@ -1,3 +1,4 @@ <?php +// El nombre por defecto es Mundo $nombre = isset($argv[1]) ? $argv[1] : \"Mundo\"; @print \"Hola, {$nombre}\\n\";","title":"Visualizar cambios"}]}